{"title":"Data Center Apprenticeship:\nR basics: Data wrangling with `dplyr`","markdown":{"yaml":{"title":"Data Center Apprenticeship:\nR basics: Data wrangling with `dplyr`","subtitle":"June 2024","date":"Last updated: `r Sys.Date()`"},"headingText":"Merging datasets","containsRefs":false,"markdown":"\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, error = FALSE)\n```\n\nData wrangling is the process of cleaning, structuring, and enriching raw data into a more usable format. The `dplyr` package is a part of the `tidyverse` and provides a set of functions that can be combined to perform the most common data wrangling tasks. The package is built around the concept of the \"grammar of data manipulation\", which is a consistent set of verbs that can be combined in many ways to achieve the desired result.\n\nIf `tidyverse` is not yet loaded in this R session, please do so now:\n\n```{r}\nlibrary(tidyverse)\n```\n\n```{r, echo=FALSE}\nstudent1 <- read_csv(\"data/student1.csv\")\nstudent2 <- read_tsv(\"data/student2.tab\", skip = 1)\nstudent3 <- readxl::read_excel(\"data/student3.xlsx\", sheet = \"Data\")\nstudent4 <- haven::read_spss(\"data/student4.sav\")\nstudent5 <- read_rds(\"data/student5.rds\")\n```\n\nThe main functions in `dplyr` are `filter()`, `select()`, `mutate()`, `arrange()`, `group_by()`, `summarize()`, and `rename()`. `dplyr` also provides a set of functions for combining datasets: `bind_rows()` and `bind_cols()` for row-wise and column-wise binding, and `left_join()`, `right_join()`, `inner_join()`, and `full_join()` for joining datasets based on common variables. These functions can be combined using the pipe operator `|>` (or `%>%`, they are mostly equivalent) to create a data wrangling workflow. The pipe operator takes the output of the function on its left and passes it as the first argument to the function on its right. This allows you to chain multiple functions together in a single line of code, making your code more readable and easier to understand.\n\nIn the following, we'll work with the `student` datasets imported in the previous section and show how to use the main `dplyr` functions to clean the data so it is suitable for analysis. These steps are useful even if the input data is quite clean, as we often need to work with only a subset of observations/variables, define new variables, or aggregate the data.\n\n\nIn our current application, we have five datasets that contain different observations of the same, larger dataset. So we can list all datasets in a row-binding function to combine them into a single dataset called `student`.\n\n```{r}\nstudent <- bind_rows(student1, student2, student3, student4, student5)\n```\n\nIn the following, we'll demonstrate the key data cleaning functions on this merged tibble.\n\n# Filtering observations\n\nIf we want to keep only a subset of observations, we can use the `filter()` function. We can specify a logical condition as the argument to `filter()`, and only observations that meet that condition will be kept. For example, to keep only students who are over 21 years old, we can use the following code:\n\n```{r}\nfilter(student, Student_Age > 21)\n```\n\nIn a pipe workflow, the same code would look like this:\n\n```{r}\nstudent |> \n  filter(Student_Age > 21)\n```\n\nWe can also apply logical conditions to character variables, e.g. to keep only students who went to a private high school and who did not receive a failing grade. Filters can be combined with AND (`,` or `&`) and OR (`|`) operators into a single function. Note the use of quotation marks around the character values in the logical condition and the double equal sign `==` to denote equality.\n\n```{r}\nstudent |> \n  filter(High_School_Type == \"Private\", Grade != \"Fail\") \n```\n\nAnother useful logical operator is `%in%`, which allows you to filter observations based on a list of values. For example, to keep only students who receive either 75% or 100% scholarships, we can use the following code:\n\n```{r}\nstudent |> \n  filter(Scholarship %in% c(\"75%\", \"100%\"))\n```\n\n# Selecting variables\n\nIf we want to keep only a subset of variables, we can use the `select()` function. We can specify the variables we want to keep (or exclude, with `-` signs) as the arguments to `select()`, and only those variables will be kept. For example, to keep only the `Id` and `Student_Age` variables, we can use the following code:\n\n```{r}\nselect(student, Id, Student_Age)\n```\n\nWe can also select columns based on their location in the dataframe or by looking for patterns in the column names:\n\n```{r}\nselect(student, 1:3) # select the first three columns\nselect(student, starts_with(\"Student\")) # select columns that start with \"Student\"\nselect(student, -Grade) # keep everything but \"Grade\"\nselect(student, -c(2, 6, 10)) # keep everything but the 2nd, 6th, and 10th columns\n```\n\nA pipe workflow allows us to combine the filtering and selecting operations into a single, step-by-step workflow:\n\n```{r}\nstudent |> \n  filter(Student_Age > 21) |> \n  select(Id, Student_Age)\n```\n\n# Creating new variables\n\nIf we want to create a new variable based on existing variables, we can use the `mutate()` function. We can specify the new variable name and the calculation for the new variable as the arguments to `mutate()`, and the new variable will be added to the dataset. For example, we can create a new variable `Daily_Study_Hours` that divides `Weekly_Study_Hours` by 5, a new variable `Class_Participation` that is a logical variable indicating whether the student has at least one \"Yes\" answer for reading, listening, and taking notes, and a new variable `Scholarship_num` that extracts the numeric value of `Scholarship` if the string contains a number.\n\n```{r}\nstudent |> \n  # create new variables\n  mutate(Daily_Study_Hours = Weekly_Study_Hours / 5,\n         Class_Participation = Reading == \"Yes\" | Listening_in_Class == \"Yes\" | Notes == \"Yes\",\n         Scholarship_num =parse_number(Scholarship)) |> \n  # show only ID and the new variables\n  select(Id, Daily_Study_Hours, Class_Participation, Scholarship_num)\n```\n\n# Sorting the data\n\nIf we want to sort the data based on one or more variables, we can use the `arrange()` function, taking the tibble and a variable list as its arguments. By default, `arrange()` sorts in ascending order, but you can specify descending order by using the `desc()` function. For example, to sort the data by `Student_Age` in descending order, and `Weekly_Study_Hours` in ascending order, we can use the following code:\n\n```{r}\nstudent |> \n  arrange(desc(Student_Age), Weekly_Study_Hours)\n```\n\n# Renaming variables\n\nIf we want to rename variables, we can use the `rename()` function with the argument structure `new name = old name`. For example, we can rename the `Student_Age` variable to `age` and the `Weekly_Study_Hours` variable to `weekly_hours`, we can use the following code:\n\n```{r}\nstudent |> \n  rename(age = Student_Age, weekly_hours = Weekly_Study_Hours)\n```\n\n# Categorical variables as factors\n\nIt is often useful to clearly define the levels of a categorical variable, especially if these levels have a meaningful ordering. For unordered categories, R provides the data type `factor`, while for ordered variables the relevant data type is `ordered`. Factor and ordered values appear as character strings when viewed, but are treated as numbers with labels internally, which makes it easier to show descriptives of the variable and include it in models. For example, we can define `High_School_Type` as a factor with three levels and `Attendance` as ordered with the `factor()` and `ordered()` functions. If we don't specify the levels of the factor explicitly, then the levels will be sorted alphabetically.\n\n```{r}\nstudent |> \n  mutate(High_School_Type = factor(High_School_Type),\n         Attendance = ordered(Attendance, levels = c(\"Never\", \"Sometimes\", \"Always\"))) |> \n  select(High_School_Type, Attendance) |> \n  # view variable types and levels by looking at the structure of the data\n  str()\n```\n\n# Data cleaning as a single pipeline\n\nUntil now we didn't save any of our data wrangling steps as new objects, so the original `student1` object is still unchanged. If we want to save the cleaned data as a new object, we can assign the result of the pipe workflow to a new object.\n\n```{r}\nstudent_subset <- student1 |> \n  filter(Student_Age > 21) |> \n  select(Id, Student_Age) |> \n  arrange(desc(Student_Age)) |> \n  rename(age = Student_Age)\n```\n\nTo prepare for the rest of the analysis, let's create a new `data` object that keeps all observations, and converts some of the indicators to numeric and logical, and rename the relevant variables to convenient \"snake case\":\n\n```{r}\ndata <- student |> \n  mutate(scholarship = parse_number(Scholarship),\n         sex = factor(Sex),\n         # ifelse contains a logical condition, a value if TRUE, and a value if FALSE\n         additional_work = ifelse(Additional_Work == \"Yes\", TRUE, FALSE),\n         reading = ifelse(Reading == \"Yes\", TRUE, FALSE),\n         notes = ifelse(Notes == \"Yes\", TRUE, FALSE),\n         listening = ifelse(Listening_in_Class == \"Yes\", TRUE, FALSE),\n         # case_when is an expansion of ifelse: it allows multiple conditions\n         # the value after the tilde (~) is the value if the condition is TRUE\n         grade = case_when(\n           Grade == \"Fail\" ~ 0,\n           Grade == \"DD\" ~ 1,\n           Grade == \"DC\" ~ 1.5,\n           Grade == \"CC\" ~ 2,\n           Grade == \"CB\" ~ 3,\n           Grade == \"BB\" ~ 3,\n           Grade == \"BA\" ~ 4,\n           Grade == \"AA\" ~ 4\n         )) |> \n  rename(id = Id, age = Student_Age) |> \n  select(id, age, sex, scholarship, additional_work, reading, notes, listening, grade)\n```\n\n```{r, echo=FALSE}\nwrite_csv(data, \"data/data.csv\")\n```\n\n# Go to\n\n-   [Introduction to R](../intro)\n-   [Finding and importing data](../import)\n-   [Summary statistics](../summary)\n-   [Data visualization with `ggplot2`](../ggplot)\n-   [Hypothesis testing / modelling](../tests)\n","srcMarkdownNoYaml":"\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, error = FALSE)\n```\n\nData wrangling is the process of cleaning, structuring, and enriching raw data into a more usable format. The `dplyr` package is a part of the `tidyverse` and provides a set of functions that can be combined to perform the most common data wrangling tasks. The package is built around the concept of the \"grammar of data manipulation\", which is a consistent set of verbs that can be combined in many ways to achieve the desired result.\n\nIf `tidyverse` is not yet loaded in this R session, please do so now:\n\n```{r}\nlibrary(tidyverse)\n```\n\n```{r, echo=FALSE}\nstudent1 <- read_csv(\"data/student1.csv\")\nstudent2 <- read_tsv(\"data/student2.tab\", skip = 1)\nstudent3 <- readxl::read_excel(\"data/student3.xlsx\", sheet = \"Data\")\nstudent4 <- haven::read_spss(\"data/student4.sav\")\nstudent5 <- read_rds(\"data/student5.rds\")\n```\n\nThe main functions in `dplyr` are `filter()`, `select()`, `mutate()`, `arrange()`, `group_by()`, `summarize()`, and `rename()`. `dplyr` also provides a set of functions for combining datasets: `bind_rows()` and `bind_cols()` for row-wise and column-wise binding, and `left_join()`, `right_join()`, `inner_join()`, and `full_join()` for joining datasets based on common variables. These functions can be combined using the pipe operator `|>` (or `%>%`, they are mostly equivalent) to create a data wrangling workflow. The pipe operator takes the output of the function on its left and passes it as the first argument to the function on its right. This allows you to chain multiple functions together in a single line of code, making your code more readable and easier to understand.\n\nIn the following, we'll work with the `student` datasets imported in the previous section and show how to use the main `dplyr` functions to clean the data so it is suitable for analysis. These steps are useful even if the input data is quite clean, as we often need to work with only a subset of observations/variables, define new variables, or aggregate the data.\n\n# Merging datasets\n\nIn our current application, we have five datasets that contain different observations of the same, larger dataset. So we can list all datasets in a row-binding function to combine them into a single dataset called `student`.\n\n```{r}\nstudent <- bind_rows(student1, student2, student3, student4, student5)\n```\n\nIn the following, we'll demonstrate the key data cleaning functions on this merged tibble.\n\n# Filtering observations\n\nIf we want to keep only a subset of observations, we can use the `filter()` function. We can specify a logical condition as the argument to `filter()`, and only observations that meet that condition will be kept. For example, to keep only students who are over 21 years old, we can use the following code:\n\n```{r}\nfilter(student, Student_Age > 21)\n```\n\nIn a pipe workflow, the same code would look like this:\n\n```{r}\nstudent |> \n  filter(Student_Age > 21)\n```\n\nWe can also apply logical conditions to character variables, e.g. to keep only students who went to a private high school and who did not receive a failing grade. Filters can be combined with AND (`,` or `&`) and OR (`|`) operators into a single function. Note the use of quotation marks around the character values in the logical condition and the double equal sign `==` to denote equality.\n\n```{r}\nstudent |> \n  filter(High_School_Type == \"Private\", Grade != \"Fail\") \n```\n\nAnother useful logical operator is `%in%`, which allows you to filter observations based on a list of values. For example, to keep only students who receive either 75% or 100% scholarships, we can use the following code:\n\n```{r}\nstudent |> \n  filter(Scholarship %in% c(\"75%\", \"100%\"))\n```\n\n# Selecting variables\n\nIf we want to keep only a subset of variables, we can use the `select()` function. We can specify the variables we want to keep (or exclude, with `-` signs) as the arguments to `select()`, and only those variables will be kept. For example, to keep only the `Id` and `Student_Age` variables, we can use the following code:\n\n```{r}\nselect(student, Id, Student_Age)\n```\n\nWe can also select columns based on their location in the dataframe or by looking for patterns in the column names:\n\n```{r}\nselect(student, 1:3) # select the first three columns\nselect(student, starts_with(\"Student\")) # select columns that start with \"Student\"\nselect(student, -Grade) # keep everything but \"Grade\"\nselect(student, -c(2, 6, 10)) # keep everything but the 2nd, 6th, and 10th columns\n```\n\nA pipe workflow allows us to combine the filtering and selecting operations into a single, step-by-step workflow:\n\n```{r}\nstudent |> \n  filter(Student_Age > 21) |> \n  select(Id, Student_Age)\n```\n\n# Creating new variables\n\nIf we want to create a new variable based on existing variables, we can use the `mutate()` function. We can specify the new variable name and the calculation for the new variable as the arguments to `mutate()`, and the new variable will be added to the dataset. For example, we can create a new variable `Daily_Study_Hours` that divides `Weekly_Study_Hours` by 5, a new variable `Class_Participation` that is a logical variable indicating whether the student has at least one \"Yes\" answer for reading, listening, and taking notes, and a new variable `Scholarship_num` that extracts the numeric value of `Scholarship` if the string contains a number.\n\n```{r}\nstudent |> \n  # create new variables\n  mutate(Daily_Study_Hours = Weekly_Study_Hours / 5,\n         Class_Participation = Reading == \"Yes\" | Listening_in_Class == \"Yes\" | Notes == \"Yes\",\n         Scholarship_num =parse_number(Scholarship)) |> \n  # show only ID and the new variables\n  select(Id, Daily_Study_Hours, Class_Participation, Scholarship_num)\n```\n\n# Sorting the data\n\nIf we want to sort the data based on one or more variables, we can use the `arrange()` function, taking the tibble and a variable list as its arguments. By default, `arrange()` sorts in ascending order, but you can specify descending order by using the `desc()` function. For example, to sort the data by `Student_Age` in descending order, and `Weekly_Study_Hours` in ascending order, we can use the following code:\n\n```{r}\nstudent |> \n  arrange(desc(Student_Age), Weekly_Study_Hours)\n```\n\n# Renaming variables\n\nIf we want to rename variables, we can use the `rename()` function with the argument structure `new name = old name`. For example, we can rename the `Student_Age` variable to `age` and the `Weekly_Study_Hours` variable to `weekly_hours`, we can use the following code:\n\n```{r}\nstudent |> \n  rename(age = Student_Age, weekly_hours = Weekly_Study_Hours)\n```\n\n# Categorical variables as factors\n\nIt is often useful to clearly define the levels of a categorical variable, especially if these levels have a meaningful ordering. For unordered categories, R provides the data type `factor`, while for ordered variables the relevant data type is `ordered`. Factor and ordered values appear as character strings when viewed, but are treated as numbers with labels internally, which makes it easier to show descriptives of the variable and include it in models. For example, we can define `High_School_Type` as a factor with three levels and `Attendance` as ordered with the `factor()` and `ordered()` functions. If we don't specify the levels of the factor explicitly, then the levels will be sorted alphabetically.\n\n```{r}\nstudent |> \n  mutate(High_School_Type = factor(High_School_Type),\n         Attendance = ordered(Attendance, levels = c(\"Never\", \"Sometimes\", \"Always\"))) |> \n  select(High_School_Type, Attendance) |> \n  # view variable types and levels by looking at the structure of the data\n  str()\n```\n\n# Data cleaning as a single pipeline\n\nUntil now we didn't save any of our data wrangling steps as new objects, so the original `student1` object is still unchanged. If we want to save the cleaned data as a new object, we can assign the result of the pipe workflow to a new object.\n\n```{r}\nstudent_subset <- student1 |> \n  filter(Student_Age > 21) |> \n  select(Id, Student_Age) |> \n  arrange(desc(Student_Age)) |> \n  rename(age = Student_Age)\n```\n\nTo prepare for the rest of the analysis, let's create a new `data` object that keeps all observations, and converts some of the indicators to numeric and logical, and rename the relevant variables to convenient \"snake case\":\n\n```{r}\ndata <- student |> \n  mutate(scholarship = parse_number(Scholarship),\n         sex = factor(Sex),\n         # ifelse contains a logical condition, a value if TRUE, and a value if FALSE\n         additional_work = ifelse(Additional_Work == \"Yes\", TRUE, FALSE),\n         reading = ifelse(Reading == \"Yes\", TRUE, FALSE),\n         notes = ifelse(Notes == \"Yes\", TRUE, FALSE),\n         listening = ifelse(Listening_in_Class == \"Yes\", TRUE, FALSE),\n         # case_when is an expansion of ifelse: it allows multiple conditions\n         # the value after the tilde (~) is the value if the condition is TRUE\n         grade = case_when(\n           Grade == \"Fail\" ~ 0,\n           Grade == \"DD\" ~ 1,\n           Grade == \"DC\" ~ 1.5,\n           Grade == \"CC\" ~ 2,\n           Grade == \"CB\" ~ 3,\n           Grade == \"BB\" ~ 3,\n           Grade == \"BA\" ~ 4,\n           Grade == \"AA\" ~ 4\n         )) |> \n  rename(id = Id, age = Student_Age) |> \n  select(id, age, sex, scholarship, additional_work, reading, notes, listening, grade)\n```\n\n```{r, echo=FALSE}\nwrite_csv(data, \"data/data.csv\")\n```\n\n# Go to\n\n-   [Introduction to R](../intro)\n-   [Finding and importing data](../import)\n-   [Summary statistics](../summary)\n-   [Data visualization with `ggplot2`](../ggplot)\n-   [Hypothesis testing / modelling](../tests)\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../../styles.css"],"toc":true,"output-file":"clean.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.555","editor":"visual","theme":"simplex","mainfont":"Cormorant SC","fontsize":"20px","title":"Data Center Apprenticeship:\nR basics: Data wrangling with `dplyr`","subtitle":"June 2024","date":"Last updated: `r Sys.Date()`"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}