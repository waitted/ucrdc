{"title":"Data Center Apprenticeship:\nData visualization","markdown":{"yaml":{"title":"Data Center Apprenticeship:\nData visualization","subtitle":"Spring 2024","date":"Last updated: `r Sys.Date()`","always_allow_html":true},"headingText":"Introduction","containsRefs":false,"markdown":"\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, error = FALSE)\n```\n\n*Schedule:*\n\n-   day 1: finish coordinate systems, maybe start with facets\n-   day 2: (facets), patchwork, theme, other packages\n\n\nThis tutorial introduces data visualization in R, primarily using the `ggplot2` package (included in `tidyverse`). The tutorial is based on [*A ggplot2 Tutorial for Beautiful Plotting in R*](https://cedricscherer.netlify.app/2019/08/05/a-ggplot2-tutorial-for-beautiful-plotting-in-r/) by CÃ©dric Scherer and [*Modern Data Visualization with R*](https://rkabacoff.github.io/datavis/index.html) by Robert Kabacoff.\n\n# Visualization with ggplot2\n\n## Packages and data\n\nYou will use the following packages and dataset to practice data visualization. The data contains information about Chicago's weather on a daily basis between 1997--2000.\n\n```{r, eval = FALSE}\nlibrary(tidyverse)\nlibrary(patchwork) # multiple plots\nlibrary(GGally) # correlation scatterplot matrix\nlibrary(scatterplot3d) # 3-D scatterplots\nlibrary(ggalluvial) # static alluvial diagram\nlibrary(networkD3) # interactive alluvial diagram\nlibrary(plotly) # interactive plots\n\n# Load the data from GitHub\nchic <- read_csv(\"https://raw.githubusercontent.com/ucrdatacenter/projects/main/apprenticeship/2024h1/3_visualization/chicago.csv\")\n```\n\n## Basic plots\n\nThe `ggplot2` package builds up figures in layers, by adding elements one at a time. You always start with a base `ggplot` where you specify the data used by the plot and possibly the variables to place on each axis. These variables are specified within an `aes()` function, which stands for aesthetics.\n\nThe `ggplot()` function in itself only creates a blank canvas; we need to add so-called geoms to actually plot the data. You can choose from a wide range of geoms, and also use multiple geoms in one plot. You can add elements to a `ggplot` objects with the `+` sign. You should think of the `+` sign in `ggplot` workflows in the same way you think of the pipe operators in data wrangling workflows.\n\n```{r, eval = FALSE}\n# Create the base of a plot with date on the x-axis and temperature on the y-axis\nggplot(chic, aes(x = date, y = temp))\n\n# Create a scatterplot\nggplot(chic, aes(x = date, y = temp)) + \n  geom_point()\n\n# Create a line plot\nggplot(chic, aes(x = date, y = temp)) + \n  geom_line()\n\n# Combine both points and lines in the plot\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point() +\n  geom_line()\n\n# Customize the appearance of points and lines\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"firebrick\", shape = \"diamond\", size = 2) + \n  geom_line(color = \"firebrick\", linetype = \"dotted\", size = .3) + \n  theme_light() # Apply a light theme\n```\n\nThe previous example used the `theme_light()` function to change the design of the plot. Instead of specifying it per individual plot, you can change the default setting for all future plots with the `theme_set()` function.\n\n```{r, eval = FALSE}\n# Set the default theme for all following plots\ntheme_set(theme_light())\n```\n\nThere are multiple ways to make axis titles more informative, such as the `xlab()` and `ylab()` functions or the `x` and `y` arguments in the `labs()` function. These elements can be added to a `ggplot` object just like any geom, theme, or other customization option.\n\n```{r, eval = FALSE}\n# Add axis labels with xlab() and ylab()\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"firebrick\") +\n  xlab(\"Year\") +\n  ylab(\"Temperature\")\n\n# Add axis labels with labs(), use math expressions\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"firebrick\") +\n  labs(x = \"Year\", y = expression(paste(\"Temperature (\", degree ~ F, \")\")))\n```\n\n## Additional aesthetics and legends\n\nIn addition to using the x and y axes to show variable values, you can use other characteristics of geoms to vary based on variables. You can add these additional characteristics -- such as color, fill, size, shape -- to the `aes()` function.\n\nNotice that R treats characters as factors, and arranges them in alphabetical order. If you would like to change this default behavior because the variable has another meaningful order (e.g. for seasons Spring should come after Winter), you can convert the variable to a factor with the levels defined in the correct order. The code below is also an example of how you can transition from a pipe workflow of data wrangling to immediately visualizing the data without needing to save the intermediate dataset as a separate object.\n\n```{r, eval = FALSE}\n# Color the scatterplot points by season\nggplot(chic, aes(x = date, y = temp, color = season)) +\n  geom_point() +\n  labs(x = \"Year\", y = \"Temperature\")\n\nchic |> \n  # Convert season to a factor with seasons in the correct order\n  mutate(season = factor(season, levels = c(\"Winter\", \"Spring\", \"Summer\", \"Autumn\"))) |> \n  # Determine the color and shape of the points by season\n  ggplot(aes(x = date, y = temp, color = season, shape = season)) +\n  geom_point() +\n  labs(x = \"Year\", y = \"Temperature\")\n```\n\nIf a step of data wrangling should apply to all plots, it is easier to save the resulting data as a new object or overwrite the original data (if it doesn't lead to a loss of information).\n\n```{r, eval = FALSE}\n# Convert season to a factor in the original data\nchic <- chic |> \n  mutate(season = factor(season, levels = c(\"Winter\", \"Spring\", \"Summer\", \"Autumn\")))\n```\n\n## Other geoms\n\nSo far you have seen point and line geoms, but there are many more. The [R Graph Gallery](https://r-graph-gallery.com/) provides a long list of common plot types, and so do Chapters 4 and 5 of [*Modern Data Visualization with R*](https://rkabacoff.github.io/datavis/index.html). Both resources group geoms by the type of variable(s) plotted.\n\nFor the frequency distribution of a continuous variable, you'd often use a histogram or density plot, while for the frequencies of a categorical variable you'd use a bar chart.\n\n```{r, eval = FALSE}\n# Histogram of temperatures\nggplot(chic, aes(temp)) +\n  geom_histogram(fill = \"grey\", color = \"red\")\n\n# Density plot of temperatures\nggplot(chic, aes(temp)) +\n  geom_density(fill = \"grey\", alpha = 0.5)\n\n# Density plot of temperatures per season\nggplot(chic, aes(temp, fill = season)) +\n  geom_density(alpha = 0.3)\n\n# Number of observations per month\nggplot(chic, aes(month)) +\n  geom_bar()\n\n# Number of observations per month, colors by year\nggplot(chic, aes(month, fill = factor(year))) +\n  geom_bar()\n\n# Number of observations per month, colors by year\nggplot(chic, aes(season, fill = factor(year))) +\n  geom_bar(position = \"dodge\")\n```\n\nTo make relationships between two continuous variables clearer, you can add smoothing curves -- you can keep the curve flexible or restrict it to a straight line.\n\n```{r, eval = FALSE}\n# Add a smooth curve to the scatterplot\nggplot(chic, aes(date, temp)) +\n  geom_point() +\n  geom_smooth() +\n  labs(x = \"Year\", y = \"Temperature\")\n\n# Use a linear fit and remove confidence interval around the line\nggplot(chic, aes(date, temp)) +\n  geom_point() +\n  geom_smooth(method = \"lm\", se = FALSE) +\n  labs(x = \"Year\", y = \"Temperature\")\n```\n\nYou can use text as geoms as well, either on top of other geoms to label them, or as the main data markers. In this case the y-coordinates of the labels correspond to the average temperature of the season.\n\n```{r, eval = FALSE}\n# Plot the mean temperature per season\nchic |> \n  # Calculate mean temperature per year and season\n  group_by(year, season) |> \n  summarize(temp = mean(temp)) |> \n  ggplot(aes(year, temp)) +\n  geom_text(aes(label = season)) +\n  labs(x = NULL, y = \"Mean temperature per season\")\n\n# geom_label is the same as geom_text but with a filled background\nchic |> \n  group_by(year, season) |> \n  summarize(temp = mean(temp)) |> \n  ggplot(aes(year, temp)) +\n  # Fill label background per season\n  geom_label(aes(label = season, fill = season)) +\n  labs(x = NULL, y = \"Mean temperature per season\")\n```\n\nYou can use various other geoms to highlight particular points or boundaries of your plot, e.g. by adding horizontal or vertical lines at key locations. An easy way to highlight particular observations is to add a new layer of geoms, where instead of the full dataset you use a filtered version with only the highlighted observations. In that case you can override the global data choice in `ggplot()` by adding a `data` argument within a geom. In this case `chic |> filter(yday %in% 358:360)` keeps the Chistmas period in all years, and highlights them in red. The dashed blue line at 32F temperature (0 Celsius) makes it easy to determine whether a particular year had below-freezing temperatures on Christmas.\n\n```{r, eval = FALSE}\nggplot(chic, aes(date, temp)) +\n  geom_point(color = \"grey70\", alpha = 0.5, size = 2) +\n  # Highlight selected points: Christmas from each year\n  geom_point(data = chic |> filter(yday %in% 358:360), color = \"red\", size = 2) +\n  # Add a horizontal line at temp == 32\n  geom_hline(yintercept = 32, color = \"blue\", linetype = \"dashed\", size = 1.5) +\n  labs(x = \"Year\", y = \"Temperature\")\n```\n\nIf you'd like to plot intervals, ribbon geoms may be useful. For each x (y) value the ribbon needs a minimum and maximum point along the y (x) axis. In this case the monthly minimum and maximum temperatures form the lower and upper bounds of the ribbon. It can also be used to plot confidence intervals or standard errors around estimated values.\n\n```{r, eval = FALSE}\n# Add a ribbon showing monthly range of temperatures\nchic |> \n  # Calculate lowest and highest temperature per month\n  group_by(year, month) |> \n  mutate(upper = max(temp), \n         lower = min(temp)) |> \n  ggplot() +\n  # use those temperatures as upper and lower bound of a ribbon\n  geom_ribbon(aes(x = date, ymin = lower, ymax = upper), alpha = 0.2) +\n  geom_point(aes(date, temp))\n```\n\nHeatmaps have a variety of uses; they are most commonly used to show correlations between predictors, but they can have any two categorical variables on the axes, and use color to show how the value of a (usually continuous) variable differs between different combinations of the categorical variables. For example this figure shows how average temperature changes in different years and seasons.\n\n```{r, eval = FALSE}\n# Heatmap of average temperature per season\nchic |> \n  # Calculate average temperature per season\n  group_by(year, season) |> \n  summarize(temp = mean(temp)) |> \n  ggplot() +\n  # geom_tile with fill aesthetic creates heatmap\n  geom_tile(aes(year, season, fill = temp)) +\n  # Add text to display average temperatures\n  geom_text(aes(year, season, label = round(temp, 1)), color = \"white\") +\n  labs(x = NULL, y = NULL, fill = \"Average\\ntemperature\")\n```\n\nTo show how relationships evole over time, you can use `geom_path` that connects observations based on their ordering in the original dataframe (so make sure that your data is properly sorted, otherwise you'll end up with nonsense results). If you have may observations, paths can look very cluttered (which is why the following example restricts the data to a single month). In those cases it may be useful to add markers to notable points, or use arrows to specify the direction of the path. In addition to highlighting observations as you have seen before, you can add segment geoms to draw lines or arrows on the plot. While you can specify the coordinates of these segments within the `ggplot` workflow, it is often clearer to store these coordinates in a separate tibble.\n\n```{r, eval = FALSE}\n# Scatterplot of temperature and ozone levels in Dec 2000 - evolution over time is unclear\nchic |> \n  filter(year == 2000, month == \"Dec\") |> \n  ggplot(aes(temp, o3)) +\n  geom_point() +\n  labs(x = \"Temperature\", y = \"Ozone\", title = \"December 2000\")\n\n# Define the coordinates of an arrow pointing to Dec 1 2000\narrow_data <- tibble(\n  x = 20,\n  y = 25,\n  xend = chic |> filter(date == ymd(20001201)) |> pull(temp),\n  yend = chic |> filter(date == ymd(20001201)) |> pull(o3)\n)\n\n# Path of temperature and ozone levels make it clear how values change over time\nchic |> \n  filter(year == 2000, month == \"Dec\") |> \n  ggplot(aes(temp, o3)) + \n  # Plot the path of temperature and ozone\n  geom_path() +\n  # Highlight Dec 31\n  geom_point(data = filter(chic, date == ymd(20001231))) +\n  # Add the previously defined arrow with geom_segment\n  geom_segment(data = arrow_data, aes(x = x, y = y, xend = xend, yend = yend),\n               # Do not use the global aesthetics from ggplot(aes())\n               inherit.aes = FALSE, color = \"red\",\n               # Specify that the segment is an arrow\n               arrow = arrow()) +\n  # Add a label to Dec 1 with coordinates defined within aes()\n  geom_text(data = NULL, aes(x = 20, y = 26, label = \"Dec 1, 2000\"), color = \"red\") +\n  labs(x = \"Temperature\", y = \"Ozone\", title = \"December 2000\")\n\n```\n\n## Scales\n\nFor any aesthetic you specify, you can override the default behavior by adding `scale_...` elements. You can manually specify legend titles, color palettes, labels, etc.\n\n```{r, eval = FALSE}\nggplot(chic, aes(x = date, y = temp, color = season)) +\n  geom_point() +\n  labs(x = \"Year\", y = \"Temperature\") +\n  # Specify the title and legend labels of the color scale\n  scale_color_discrete(\n    name = \"Seasons:\",\n    labels = c(\"MarâMay\", \"JunâAug\", \"SepâNov\", \"DecâFeb\")\n  )\n\nggplot(chic, aes(x = date, y = temp, color = season)) +\n  geom_point() +\n  labs(x = \"Year\", y = \"Temperature\") +\n  # Manually specify the colors per season\n  scale_color_manual(values = c(\"darkblue\", \"green3\", \"pink\", \"gold\"))\n\n\nggplot(chic, aes(x = date, y = temp, color = season)) +\n  geom_point() +\n  labs(x = \"Year\", y = \"Temperature\") +\n  # Use a predefined color palette from RColorBrewer\n  scale_colour_brewer(type = \"qual\", palette = 2)\n\nggplot(chic, aes(x = date, y = temp, color = o3, shape = season)) +\n  geom_point() +\n  labs(x = \"Year\", y = \"Temperature\") +\n  # Use a gradient color palette specifying the endpoints\n  scale_color_gradient(low = \"lightblue\", high = \"darkblue\") +\n  # Manually specify the shapes per season\n  scale_shape_manual(values = c(15, 16, 17, 18))\n```\n\n## Coordinate systems\n\nSimilarly to scales, you can adjust the default behavior of the x and y axes as well (e.g. specify different axis limits, breaks, or labels), either by the `scale_x_...()/scale_y_...()` arguments or by changing the coordinate system with `coord_...()`.\n\n`scale_x_...()/scale_y_...()` is most useful for changing the axis breaks and labels, while `coord_...()` can e.g. flip the axes, adjust the aspect ratio (see `coord_fixed()`), and determine whether observations beyond the plot boundaries should be displayed.\n\nBoth `scale` and `coord` can adjust axis limits, with a subtle difference in their behavior.\n\n```{r, eval = FALSE}\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"firebrick\") +\n  labs(x = \"Year\", y = \"Temperature\") +\n  # Only plot observations with temp between 0-50 \n  scale_y_continuous(limits = c(0, 50))\n\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"firebrick\") +\n  labs(x = \"Year\", y = \"Temperature\") +\n  # Limit the y-axis between 0 and 50, but don't filter out points\n  coord_cartesian(y = c(0, 50))\n\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"firebrick\") +\n  labs(x = \"Year\", y = \"Temperature\") +\n  # Limit the y-axis between 0 and 50, and let points show beyond the plot panel up to the plot margins\n  coord_cartesian(y = c(0, 50), clip = \"off\")\n\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"firebrick\") +\n  labs(x = \"Year\", y = \"Temperature\") +\n  # Customize y-axis breaks to be 0, 10, 20, ... 90\n  scale_y_continuous(breaks = seq(0, 90, 10), minor_breaks = NULL) +\n  # Customize x-axis breaks to be every 6 months in the format of year-month\n  scale_x_date(date_breaks = \"6 months\", date_labels = \"%Y-%b\", minor_breaks = NULL)\n\nggplot(chic, aes(temp)) +\n  geom_histogram(fill = \"grey\", color = \"red\") +\n  # Flip the x and y axes\n  coord_flip()\n\nggplot(chic, aes(temp)) +\n  geom_histogram(fill = \"grey\", color = \"red\") +\n  # Reverse the x axis\n  scale_x_reverse()\n```\n\n## Multiple plots\n\nOften you would like to present multiple plots side-by-side: maybe show how the relationship between variables differs depending on some groupings of observations (and putting all observations on a single plot looks too cluttered), or compare how different outcome variables react to changes in an explanatory variable. The two main ways to nicely arrange plots are\n\n-   creating a single plot with multiple panels, known as facets;\n-   creating multiple independent plots, and arranging them into one figure afterwards.\n\n### Using facets\n\nBy specifying a grouping variable along which to facet, you can create a separate plot for each value of your facet variable. You can create faceted plots by adding `facet_wrap()` to your `ggplot` object, and specify the faceting variable with a tilde (`~`). You can also specify additional arguments such as whether to allow the axis limits to vary between panels. Only use variables with relatively few unique values as your facet dimension, otherwise R will attempt to create far too many plots, which takes a long time and might even crash your R session.\n\n```{r, eval = FALSE}\n# Change the default theme to bw\ntheme_set(theme_bw())\n\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"orangered\", alpha = .3) +\n  labs(x = \"Year\", y = \"Temperature\") +\n  # Create separate plots per year\n  facet_wrap(~year)\n\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"orangered\", alpha = .3) +\n  labs(x = \"Year\", y = \"Temperature\") +\n  # Create separate plots per year and allow different x-axes per plot\n  facet_wrap(~year, scales = \"free_x\")\n\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"orangered\", alpha = .3) +\n  labs(x = \"Year\", y = \"Temperature\") +\n  # Create separate plots per season, arrange all plots in one row, let all scales vary\n  facet_wrap(~season, nrow = 1, scales = \"free\")\n```\n\nIf you would like to group your data based on two variables, you can use `facet_grid()`, separating your two variables with a tilde. However, note that axis limit customization options are more limited with `facet_grid()`, so if you need your axes to vary within columns/rows as well, you can use `facet_wrap()` with the same two-variable argument as well. However, with `facet_wrap()` your faceting variables are \"stuck\" together, which makes the overview of which dimension corresponds to changes in whcih faceting variable less clear.\n\n```{r, eval = FALSE}\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"orangered\", alpha = .3) +\n  labs(x = \"Year\", y = \"Temperature\") +\n  # Arrange plots vertically per year and horizontally per season with facet_grid\n  facet_grid(year~season)\n\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"orangered\", alpha = .3) +\n  labs(x = \"Year\", y = \"Temperature\") +\n  # Same but with facet_wrap\n  facet_wrap(year~season, scales = \"free\")\n```\n\n### Combining independent plots with `patchwork`\n\nIn order to nicely arrange separate plots and same them as a single file, you can use the `patchwork packages`. First you need to save each of your plots into an R object (here `p1`, `p2`, `p3`), then use `+` signs to combine the plots horizontally, and `/` signs to combine them vertically. You can make these layouts as complex as you want to by using parentheses to group rows. Alternatively, you can specify custom layout options, including additional options such as whether to repeat or collect legends, by adding a `plot_layout()` function to the plot objects.\n\n```{r, eval = FALSE}\n# Create and save plots of temp, ozone level and dewpoint over time\n\np1 <- ggplot(chic, aes(x = date, y = temp, color = season)) +\n  geom_point() +\n  labs(x = \"Year\", y = \"Temperature\")\n\np2 <- ggplot(chic, aes(x = date, y = o3, color = season)) +\n  geom_point() +\n  labs(x = \"Year\", y = \"Ozone\")\n\np3 <- ggplot(chic, aes(x = date, y = dewpoint, color = season)) +\n  geom_point() +\n  labs(x = \"Year\", y = \"Dewpoint\")\n\n# Combine temp and ozone horizontally\np1 + p2\n\n# Combine temp and ozone vertically\np1 / p2\n\n# Combine temp and ozone vertically with plot_layout, do not repeat legends\np1 + p2 + plot_layout(ncol = 1, guides = \"collect\")\n\n# Arrange p1 and p2 horizontally on top, p1, p2 and p3 horizontally below\n(p1 + p2) / (p1 + p2 + p3) + plot_layout(guides = \"collect\")\n```\n\nOften it is possible to achieve your desired plot layout both by faceting or with `patchwork`, but depending on your goal and the structure of your data, one approach may be easier than the other. A good rule to keep in mind is that faceting wants data in long format, while `patchwork` often wants wide format: faceting needs a grouping variable that for each observation defines which facet it should go on, while in `patchwork` you can change the aesthetics between plots, so you can easily switch which variables to use per plot.\n\nThe following example shows how we can create the same plots with faceting as with `patchwork` by converting the data to long format where the `name` variable specifies whether the value is the value of temperature, ozone, or dewpoint.\n\n```{r, eval = FALSE}\n# Side-by-side plots of temperature, ozone and dewpoint with facet_wrap\nchic |> \n  # Convert data to long format with variable names to \"name\" and values to \"value\" \n  pivot_longer(c(temp, o3, dewpoint)) |> \n  ggplot(aes(date, value, color = season)) +\n  geom_point() + \n  # Facet by variable name, arrange in one column\n  facet_wrap(~name, ncol = 1)\n```\n\n## Customizing plot elements\n\nSo far we modified the default theme (aka `theme_grey()`) by specifying alternative predefined themes (e.g. `theme_light()`). A way to customize plot elements even further is to change the `theme()` function by redefining particular plot elements.\n\nEvery design element of a plot (panel, grid, axes, text, legend keys, etc.) can be changed with an `element_...()` function (e.g. `element_text()` for text, `element_line()` for lines, `element_blank()` if the element shouldn't be displayed). Each element type has different characteristics you can customize; a few examples are shown here. The help file of the `theme()` functions describes the options in detail.\n\n```{r, eval = FALSE}\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"firebrick\") +\n  labs(x = \"Year\", y = \"Temperature (F)\") +\n  # Customize axis title fonts\n  theme(axis.title = element_text(size = 15, color = \"firebrick\", face = \"italic\"),\n        # Remove y-axis ticks\n        axis.ticks.y = element_blank(),\n        # Change minor grid to dashed lines\n        panel.grid.minor = element_line(linetype = \"dashed\"))\n\nggplot(chic, aes(x = date, y = temp, color = season)) +\n  geom_point() +\n  labs(x = \"Year\", y = \"Temperature\", color = \"Season\") +\n  # Move legend to above the plot\n  theme(legend.position = \"top\",\n        # Change legend background color\n        legend.background = element_rect(fill = \"grey90\"),\n        # Remove legend title\n        legend.title = element_blank())\n\nggplot(chic, aes(x = date, y = temp, color = season)) +\n  geom_point() +\n  labs(x = \"Year\", y = \"Temperature\") +\n  # Move legend to coordinates within the plot\n  theme(legend.position = c(0.85, 0.2),\n        # Add whitespace to the left side of the plot\n        plot.margin = margin(l = 50))\n```\n\nIn addition to the `theme()` function there are also other ways to customize legends. You can change what key shape to use by specifying the `key_glyph` within a geom (for the available options of shapes, see [here](https://ggplot2.tidyverse.org/reference/draw_key.html)). You can also add a `guides()` function to your `ggplot` object: some options there overlap with options in `theme()`, but there are also additional arguments such as arranging legend items in multiple rows/columns or specifying the order of legends if there are multiple.\n\n```{r, eval = FALSE}\nggplot(chic, aes(x = date, y = temp, color = season)) +\n  geom_point(key_glyph = \"vline\") +\n  labs(x = \"Year\", y = \"Temperature\") +\n  # Customize the legend further with guide_legend()\n  guides(color = guide_legend(\"Season:\", title.hjust = 0.5, nrow = 2))\n```\n\n## Saving plots\n\nYou can save `ggplot` objects to use outside of the R environment with the `ggsave` function. You can specify an existing `ggplot` object as the first argument, but by default `ggsave()` saves the last plot displayed in your Plots panel. You always need to specify the file path of the saved plot, including the preferred file format (e.g. .png, .jpg, .pdf). You can adjust the plot size with the `scale` argument or by specifying the height and width in your preferred units (the default units are inches).\n\n```{r, eval = FALSE}\nggplot(chic, aes(x = date, y = temp)) + \n  geom_point()\n\n# Save last plot\nggsave(\"figures/plot1.png\", scale = 1.5)\n\np <- ggplot(chic, aes(x = date, y = temp)) + \n  geom_point()\n\n# Save plot saved to the Environment\nggsave(p, \"figures/plot2.png\", height = 10, width = 15, units = \"cm\")\n```\n\n# Other plotting packages and plot types\n\nWhile `ggplot` is extremely flexible and therefore sufficient for most of your plotting needs, it is good to be aware of how to use a few other packages developed for more specific purposes.\n\n## Correlation scatterplot matrix with `GGally`\n\nTo estimate the relationships between a set of (continuous) variables in a dataset, you'd usually calculate a correlation matrix. The `ggpairs()` function from the `GGally` packages presents both this correlation matrix, and plots the distribution of each variable and the relationships for each variable pair. You can adjust the default function e.g. by specifying an additional grouping variable; for more options, see the examples in [*Modern Data Visualization with R*](https://rkabacoff.github.io/datavis/Other.html#scatterplot-matrix).\n\n```{r, eval = FALSE}\nchic |> \n  # Keep only 4 continuous variables\n  select(temp, o3, dewpoint, pm10) |> \n  # Create correlation matrix of the selected variables\n  ggpairs()\n\nchic |> \n  # Keep 4 continuous variables and season as the grouping variable\n  select(temp, o3, dewpoint, pm10, season) |> \n  # Recreate the previous plot but group observations by season\n  # Use only the first 4 columns for the plots (exclude season)\n  ggpairs(columns = 1:4, ggplot2::aes(color = season))\n```\n\n## Pie chart\n\nWhile data scientists do not recommend using pie charts (because humans are quite bad at comparing areas, and better at comparing lengths such as on bar charts), you can nevertheless create pie charts in `ggplot`. In order to do so, you need to create a bar chart, and change the coordinate system to polar coordinates. To make the bars look nice, you should specify your aesthetics and geoms similarly to the example below.\n\n```{r, eval = FALSE}\nchic |> \n  # Get the number of observations per month\n  count(month) |> \n  # Specify y as the counts and fill as the categorical variable\n  ggplot(aes(x = \"\", y = n, fill = month)) +\n  # Create bars with white borders\n  geom_bar(stat = \"identity\", width = 1, color = \"white\") +\n  # Change coordinate system to polar coordinates instead of Cartesian\n  coord_polar(\"y\", start = 0) +\n  # Remove background theme elements\n  theme_void()\n```\n\n## 3-D scatterplot\n\nSimilarly to pie charts, 3-D plots are also discouraged because they are hard to interpret, so use them only if absolutely necessary. In that case, the `scatterplot3d` package contains the `scatterplot3d()` function where you need to specify the variables to put on each axis. Note that this function does not have a separate `data` argument, so you need to specify the variables by extracting the column from the dataframe with the `$` operator.\n\n```{r, eval = FALSE}\n# Create a 3-D scatterplot of temperature, dewpoint and ozone levels\nscatterplot3d(x = chic$temp,\n              y = chic$dewpoint, \n              z = chic$o3)\n```\n\n## Alluvial/Sankey diagrams with `ggalluvial` and `networkD3`\n\nAn interesting plot type is an alluvial diagram, also known as a Sankey diagram. It shows flows between different categories, and is frequently used e.g. to show changes over time in the share of observations belonging to particular groups (e.g. what energy sources households use in 1950 versus in 2000). For demonstration purposes, we'll instead look at how observations per different seasons are split between high and low temperatures (e.g. expecting to see mostly low temperatures in Winter).\n\nIn order to create a static alluvial diagram, you can use the `ggalluvial` package and standard `ggplot` workflows with `alluvium` and `stratum` geoms.\n\n```{r, eval = FALSE}\nchic |> \n  # Redefine temperature as a categorical variable: above mean temperature is high, below is low\n  mutate(temp = ifelse(temp > mean(temp), \"High temp\", \"Low temp\")) |> \n  # Get number of observations per year, season, temp category\n  count(year, season, temp) |> \n  # axis1, axis2, axis3 are the categorical grouping variables, y is the number of observations per group\n  ggplot(aes(axis1 = year, axis2 = season, axis3 = temp, y = n)) +\n  # Create flows, with colors per year\n  geom_alluvium(aes(fill = factor(year))) +\n  # Add rectangles for the categories of each variable\n  geom_stratum() +\n  # Label the rectangles\n  geom_text(stat = \"stratum\", \n            aes(label = after_stat(stratum))) +\n  # Remove background plot elements and legend\n  theme_void() +\n  theme(legend.position = \"none\")\n```\n\nFor an interactive version of the previous plot, you can use the `networkD3` package, however, note that this package requires the input data to have quite a specific format. You need a dataframe of the widths (frequencies/shares) of each link, specifying a numeric identifier for the source and target nodes. In addition, you need a dataframe of nodes that matches the numeric IDs to node names. Once you have both of these dataframes, you can use the `sankeyNetwork()` function. Note that creating the input dataframes gets significantly more complex if the diagram has more than two levels.\n\n(Interactive plots do not display properly on the website.)\n\n```{r, eval = FALSE}\n# Create a tibble of links with 3 variables: source, target, number of observations\nlinks <- chic |> \n  # Redefine temp to hig/low categorical\n  mutate(temp = ifelse(temp > mean(temp), \"High temp\", \"Low temp\")) |> \n  # Number of observations per season-temperature combination\n  count(season, temp)\n\n# Create a tibble of nodes by listing the unique categories in the links tibble\nnodes <- tibble(name = unique(c(links$season, links$temp)))\n\n# Add numerical identifiers of the nodes to the links tibble by using the row index in the nodes tibble \n# Subtract 1 to start the count at 0\nlinks$IDseason <- match(links$season, nodes$name)-1\nlinks$IDtemp <- match(links$temp, nodes$name)-1\n\n# Create an interactive Sankey diagram from the links and nodes tibbles, the numerical category IDs, the observation counts per link and the variable name of the nodes tibble\nsankeyNetwork(Links = links, Nodes = nodes, Source = \"IDseason\",\n              Target = \"IDtemp\", Value = \"n\", NodeID = \"name\")\n```\n\n## Interactive charts with `plotly`\n\nIf you work with interactive documents, you might want to make your plots interactive as well, e.g. by highlighting the data points that a user hovers over. It is very easy to turn `ggplot` objects into interactive plots with the `plotly` package: just save the `ggplot` to an object, and use that object as the argument of the `ggplotly()` function.\n\n(Interactive plots do not display properly on the website.)\n\n```{r, eval = FALSE}\n# Define a simple plot and assign to an object\np <- ggplot(chic, aes(x = date, y = temp, color = season)) +\n  geom_point() +\n  labs(x = \"Year\", y = \"Temperature\")\n\n# Display the plot as an interactive plot \nggplotly(p)\n```\n","srcMarkdownNoYaml":"\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, error = FALSE)\n```\n\n*Schedule:*\n\n-   day 1: finish coordinate systems, maybe start with facets\n-   day 2: (facets), patchwork, theme, other packages\n\n# Introduction\n\nThis tutorial introduces data visualization in R, primarily using the `ggplot2` package (included in `tidyverse`). The tutorial is based on [*A ggplot2 Tutorial for Beautiful Plotting in R*](https://cedricscherer.netlify.app/2019/08/05/a-ggplot2-tutorial-for-beautiful-plotting-in-r/) by CÃ©dric Scherer and [*Modern Data Visualization with R*](https://rkabacoff.github.io/datavis/index.html) by Robert Kabacoff.\n\n# Visualization with ggplot2\n\n## Packages and data\n\nYou will use the following packages and dataset to practice data visualization. The data contains information about Chicago's weather on a daily basis between 1997--2000.\n\n```{r, eval = FALSE}\nlibrary(tidyverse)\nlibrary(patchwork) # multiple plots\nlibrary(GGally) # correlation scatterplot matrix\nlibrary(scatterplot3d) # 3-D scatterplots\nlibrary(ggalluvial) # static alluvial diagram\nlibrary(networkD3) # interactive alluvial diagram\nlibrary(plotly) # interactive plots\n\n# Load the data from GitHub\nchic <- read_csv(\"https://raw.githubusercontent.com/ucrdatacenter/projects/main/apprenticeship/2024h1/3_visualization/chicago.csv\")\n```\n\n## Basic plots\n\nThe `ggplot2` package builds up figures in layers, by adding elements one at a time. You always start with a base `ggplot` where you specify the data used by the plot and possibly the variables to place on each axis. These variables are specified within an `aes()` function, which stands for aesthetics.\n\nThe `ggplot()` function in itself only creates a blank canvas; we need to add so-called geoms to actually plot the data. You can choose from a wide range of geoms, and also use multiple geoms in one plot. You can add elements to a `ggplot` objects with the `+` sign. You should think of the `+` sign in `ggplot` workflows in the same way you think of the pipe operators in data wrangling workflows.\n\n```{r, eval = FALSE}\n# Create the base of a plot with date on the x-axis and temperature on the y-axis\nggplot(chic, aes(x = date, y = temp))\n\n# Create a scatterplot\nggplot(chic, aes(x = date, y = temp)) + \n  geom_point()\n\n# Create a line plot\nggplot(chic, aes(x = date, y = temp)) + \n  geom_line()\n\n# Combine both points and lines in the plot\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point() +\n  geom_line()\n\n# Customize the appearance of points and lines\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"firebrick\", shape = \"diamond\", size = 2) + \n  geom_line(color = \"firebrick\", linetype = \"dotted\", size = .3) + \n  theme_light() # Apply a light theme\n```\n\nThe previous example used the `theme_light()` function to change the design of the plot. Instead of specifying it per individual plot, you can change the default setting for all future plots with the `theme_set()` function.\n\n```{r, eval = FALSE}\n# Set the default theme for all following plots\ntheme_set(theme_light())\n```\n\nThere are multiple ways to make axis titles more informative, such as the `xlab()` and `ylab()` functions or the `x` and `y` arguments in the `labs()` function. These elements can be added to a `ggplot` object just like any geom, theme, or other customization option.\n\n```{r, eval = FALSE}\n# Add axis labels with xlab() and ylab()\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"firebrick\") +\n  xlab(\"Year\") +\n  ylab(\"Temperature\")\n\n# Add axis labels with labs(), use math expressions\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"firebrick\") +\n  labs(x = \"Year\", y = expression(paste(\"Temperature (\", degree ~ F, \")\")))\n```\n\n## Additional aesthetics and legends\n\nIn addition to using the x and y axes to show variable values, you can use other characteristics of geoms to vary based on variables. You can add these additional characteristics -- such as color, fill, size, shape -- to the `aes()` function.\n\nNotice that R treats characters as factors, and arranges them in alphabetical order. If you would like to change this default behavior because the variable has another meaningful order (e.g. for seasons Spring should come after Winter), you can convert the variable to a factor with the levels defined in the correct order. The code below is also an example of how you can transition from a pipe workflow of data wrangling to immediately visualizing the data without needing to save the intermediate dataset as a separate object.\n\n```{r, eval = FALSE}\n# Color the scatterplot points by season\nggplot(chic, aes(x = date, y = temp, color = season)) +\n  geom_point() +\n  labs(x = \"Year\", y = \"Temperature\")\n\nchic |> \n  # Convert season to a factor with seasons in the correct order\n  mutate(season = factor(season, levels = c(\"Winter\", \"Spring\", \"Summer\", \"Autumn\"))) |> \n  # Determine the color and shape of the points by season\n  ggplot(aes(x = date, y = temp, color = season, shape = season)) +\n  geom_point() +\n  labs(x = \"Year\", y = \"Temperature\")\n```\n\nIf a step of data wrangling should apply to all plots, it is easier to save the resulting data as a new object or overwrite the original data (if it doesn't lead to a loss of information).\n\n```{r, eval = FALSE}\n# Convert season to a factor in the original data\nchic <- chic |> \n  mutate(season = factor(season, levels = c(\"Winter\", \"Spring\", \"Summer\", \"Autumn\")))\n```\n\n## Other geoms\n\nSo far you have seen point and line geoms, but there are many more. The [R Graph Gallery](https://r-graph-gallery.com/) provides a long list of common plot types, and so do Chapters 4 and 5 of [*Modern Data Visualization with R*](https://rkabacoff.github.io/datavis/index.html). Both resources group geoms by the type of variable(s) plotted.\n\nFor the frequency distribution of a continuous variable, you'd often use a histogram or density plot, while for the frequencies of a categorical variable you'd use a bar chart.\n\n```{r, eval = FALSE}\n# Histogram of temperatures\nggplot(chic, aes(temp)) +\n  geom_histogram(fill = \"grey\", color = \"red\")\n\n# Density plot of temperatures\nggplot(chic, aes(temp)) +\n  geom_density(fill = \"grey\", alpha = 0.5)\n\n# Density plot of temperatures per season\nggplot(chic, aes(temp, fill = season)) +\n  geom_density(alpha = 0.3)\n\n# Number of observations per month\nggplot(chic, aes(month)) +\n  geom_bar()\n\n# Number of observations per month, colors by year\nggplot(chic, aes(month, fill = factor(year))) +\n  geom_bar()\n\n# Number of observations per month, colors by year\nggplot(chic, aes(season, fill = factor(year))) +\n  geom_bar(position = \"dodge\")\n```\n\nTo make relationships between two continuous variables clearer, you can add smoothing curves -- you can keep the curve flexible or restrict it to a straight line.\n\n```{r, eval = FALSE}\n# Add a smooth curve to the scatterplot\nggplot(chic, aes(date, temp)) +\n  geom_point() +\n  geom_smooth() +\n  labs(x = \"Year\", y = \"Temperature\")\n\n# Use a linear fit and remove confidence interval around the line\nggplot(chic, aes(date, temp)) +\n  geom_point() +\n  geom_smooth(method = \"lm\", se = FALSE) +\n  labs(x = \"Year\", y = \"Temperature\")\n```\n\nYou can use text as geoms as well, either on top of other geoms to label them, or as the main data markers. In this case the y-coordinates of the labels correspond to the average temperature of the season.\n\n```{r, eval = FALSE}\n# Plot the mean temperature per season\nchic |> \n  # Calculate mean temperature per year and season\n  group_by(year, season) |> \n  summarize(temp = mean(temp)) |> \n  ggplot(aes(year, temp)) +\n  geom_text(aes(label = season)) +\n  labs(x = NULL, y = \"Mean temperature per season\")\n\n# geom_label is the same as geom_text but with a filled background\nchic |> \n  group_by(year, season) |> \n  summarize(temp = mean(temp)) |> \n  ggplot(aes(year, temp)) +\n  # Fill label background per season\n  geom_label(aes(label = season, fill = season)) +\n  labs(x = NULL, y = \"Mean temperature per season\")\n```\n\nYou can use various other geoms to highlight particular points or boundaries of your plot, e.g. by adding horizontal or vertical lines at key locations. An easy way to highlight particular observations is to add a new layer of geoms, where instead of the full dataset you use a filtered version with only the highlighted observations. In that case you can override the global data choice in `ggplot()` by adding a `data` argument within a geom. In this case `chic |> filter(yday %in% 358:360)` keeps the Chistmas period in all years, and highlights them in red. The dashed blue line at 32F temperature (0 Celsius) makes it easy to determine whether a particular year had below-freezing temperatures on Christmas.\n\n```{r, eval = FALSE}\nggplot(chic, aes(date, temp)) +\n  geom_point(color = \"grey70\", alpha = 0.5, size = 2) +\n  # Highlight selected points: Christmas from each year\n  geom_point(data = chic |> filter(yday %in% 358:360), color = \"red\", size = 2) +\n  # Add a horizontal line at temp == 32\n  geom_hline(yintercept = 32, color = \"blue\", linetype = \"dashed\", size = 1.5) +\n  labs(x = \"Year\", y = \"Temperature\")\n```\n\nIf you'd like to plot intervals, ribbon geoms may be useful. For each x (y) value the ribbon needs a minimum and maximum point along the y (x) axis. In this case the monthly minimum and maximum temperatures form the lower and upper bounds of the ribbon. It can also be used to plot confidence intervals or standard errors around estimated values.\n\n```{r, eval = FALSE}\n# Add a ribbon showing monthly range of temperatures\nchic |> \n  # Calculate lowest and highest temperature per month\n  group_by(year, month) |> \n  mutate(upper = max(temp), \n         lower = min(temp)) |> \n  ggplot() +\n  # use those temperatures as upper and lower bound of a ribbon\n  geom_ribbon(aes(x = date, ymin = lower, ymax = upper), alpha = 0.2) +\n  geom_point(aes(date, temp))\n```\n\nHeatmaps have a variety of uses; they are most commonly used to show correlations between predictors, but they can have any two categorical variables on the axes, and use color to show how the value of a (usually continuous) variable differs between different combinations of the categorical variables. For example this figure shows how average temperature changes in different years and seasons.\n\n```{r, eval = FALSE}\n# Heatmap of average temperature per season\nchic |> \n  # Calculate average temperature per season\n  group_by(year, season) |> \n  summarize(temp = mean(temp)) |> \n  ggplot() +\n  # geom_tile with fill aesthetic creates heatmap\n  geom_tile(aes(year, season, fill = temp)) +\n  # Add text to display average temperatures\n  geom_text(aes(year, season, label = round(temp, 1)), color = \"white\") +\n  labs(x = NULL, y = NULL, fill = \"Average\\ntemperature\")\n```\n\nTo show how relationships evole over time, you can use `geom_path` that connects observations based on their ordering in the original dataframe (so make sure that your data is properly sorted, otherwise you'll end up with nonsense results). If you have may observations, paths can look very cluttered (which is why the following example restricts the data to a single month). In those cases it may be useful to add markers to notable points, or use arrows to specify the direction of the path. In addition to highlighting observations as you have seen before, you can add segment geoms to draw lines or arrows on the plot. While you can specify the coordinates of these segments within the `ggplot` workflow, it is often clearer to store these coordinates in a separate tibble.\n\n```{r, eval = FALSE}\n# Scatterplot of temperature and ozone levels in Dec 2000 - evolution over time is unclear\nchic |> \n  filter(year == 2000, month == \"Dec\") |> \n  ggplot(aes(temp, o3)) +\n  geom_point() +\n  labs(x = \"Temperature\", y = \"Ozone\", title = \"December 2000\")\n\n# Define the coordinates of an arrow pointing to Dec 1 2000\narrow_data <- tibble(\n  x = 20,\n  y = 25,\n  xend = chic |> filter(date == ymd(20001201)) |> pull(temp),\n  yend = chic |> filter(date == ymd(20001201)) |> pull(o3)\n)\n\n# Path of temperature and ozone levels make it clear how values change over time\nchic |> \n  filter(year == 2000, month == \"Dec\") |> \n  ggplot(aes(temp, o3)) + \n  # Plot the path of temperature and ozone\n  geom_path() +\n  # Highlight Dec 31\n  geom_point(data = filter(chic, date == ymd(20001231))) +\n  # Add the previously defined arrow with geom_segment\n  geom_segment(data = arrow_data, aes(x = x, y = y, xend = xend, yend = yend),\n               # Do not use the global aesthetics from ggplot(aes())\n               inherit.aes = FALSE, color = \"red\",\n               # Specify that the segment is an arrow\n               arrow = arrow()) +\n  # Add a label to Dec 1 with coordinates defined within aes()\n  geom_text(data = NULL, aes(x = 20, y = 26, label = \"Dec 1, 2000\"), color = \"red\") +\n  labs(x = \"Temperature\", y = \"Ozone\", title = \"December 2000\")\n\n```\n\n## Scales\n\nFor any aesthetic you specify, you can override the default behavior by adding `scale_...` elements. You can manually specify legend titles, color palettes, labels, etc.\n\n```{r, eval = FALSE}\nggplot(chic, aes(x = date, y = temp, color = season)) +\n  geom_point() +\n  labs(x = \"Year\", y = \"Temperature\") +\n  # Specify the title and legend labels of the color scale\n  scale_color_discrete(\n    name = \"Seasons:\",\n    labels = c(\"MarâMay\", \"JunâAug\", \"SepâNov\", \"DecâFeb\")\n  )\n\nggplot(chic, aes(x = date, y = temp, color = season)) +\n  geom_point() +\n  labs(x = \"Year\", y = \"Temperature\") +\n  # Manually specify the colors per season\n  scale_color_manual(values = c(\"darkblue\", \"green3\", \"pink\", \"gold\"))\n\n\nggplot(chic, aes(x = date, y = temp, color = season)) +\n  geom_point() +\n  labs(x = \"Year\", y = \"Temperature\") +\n  # Use a predefined color palette from RColorBrewer\n  scale_colour_brewer(type = \"qual\", palette = 2)\n\nggplot(chic, aes(x = date, y = temp, color = o3, shape = season)) +\n  geom_point() +\n  labs(x = \"Year\", y = \"Temperature\") +\n  # Use a gradient color palette specifying the endpoints\n  scale_color_gradient(low = \"lightblue\", high = \"darkblue\") +\n  # Manually specify the shapes per season\n  scale_shape_manual(values = c(15, 16, 17, 18))\n```\n\n## Coordinate systems\n\nSimilarly to scales, you can adjust the default behavior of the x and y axes as well (e.g. specify different axis limits, breaks, or labels), either by the `scale_x_...()/scale_y_...()` arguments or by changing the coordinate system with `coord_...()`.\n\n`scale_x_...()/scale_y_...()` is most useful for changing the axis breaks and labels, while `coord_...()` can e.g. flip the axes, adjust the aspect ratio (see `coord_fixed()`), and determine whether observations beyond the plot boundaries should be displayed.\n\nBoth `scale` and `coord` can adjust axis limits, with a subtle difference in their behavior.\n\n```{r, eval = FALSE}\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"firebrick\") +\n  labs(x = \"Year\", y = \"Temperature\") +\n  # Only plot observations with temp between 0-50 \n  scale_y_continuous(limits = c(0, 50))\n\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"firebrick\") +\n  labs(x = \"Year\", y = \"Temperature\") +\n  # Limit the y-axis between 0 and 50, but don't filter out points\n  coord_cartesian(y = c(0, 50))\n\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"firebrick\") +\n  labs(x = \"Year\", y = \"Temperature\") +\n  # Limit the y-axis between 0 and 50, and let points show beyond the plot panel up to the plot margins\n  coord_cartesian(y = c(0, 50), clip = \"off\")\n\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"firebrick\") +\n  labs(x = \"Year\", y = \"Temperature\") +\n  # Customize y-axis breaks to be 0, 10, 20, ... 90\n  scale_y_continuous(breaks = seq(0, 90, 10), minor_breaks = NULL) +\n  # Customize x-axis breaks to be every 6 months in the format of year-month\n  scale_x_date(date_breaks = \"6 months\", date_labels = \"%Y-%b\", minor_breaks = NULL)\n\nggplot(chic, aes(temp)) +\n  geom_histogram(fill = \"grey\", color = \"red\") +\n  # Flip the x and y axes\n  coord_flip()\n\nggplot(chic, aes(temp)) +\n  geom_histogram(fill = \"grey\", color = \"red\") +\n  # Reverse the x axis\n  scale_x_reverse()\n```\n\n## Multiple plots\n\nOften you would like to present multiple plots side-by-side: maybe show how the relationship between variables differs depending on some groupings of observations (and putting all observations on a single plot looks too cluttered), or compare how different outcome variables react to changes in an explanatory variable. The two main ways to nicely arrange plots are\n\n-   creating a single plot with multiple panels, known as facets;\n-   creating multiple independent plots, and arranging them into one figure afterwards.\n\n### Using facets\n\nBy specifying a grouping variable along which to facet, you can create a separate plot for each value of your facet variable. You can create faceted plots by adding `facet_wrap()` to your `ggplot` object, and specify the faceting variable with a tilde (`~`). You can also specify additional arguments such as whether to allow the axis limits to vary between panels. Only use variables with relatively few unique values as your facet dimension, otherwise R will attempt to create far too many plots, which takes a long time and might even crash your R session.\n\n```{r, eval = FALSE}\n# Change the default theme to bw\ntheme_set(theme_bw())\n\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"orangered\", alpha = .3) +\n  labs(x = \"Year\", y = \"Temperature\") +\n  # Create separate plots per year\n  facet_wrap(~year)\n\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"orangered\", alpha = .3) +\n  labs(x = \"Year\", y = \"Temperature\") +\n  # Create separate plots per year and allow different x-axes per plot\n  facet_wrap(~year, scales = \"free_x\")\n\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"orangered\", alpha = .3) +\n  labs(x = \"Year\", y = \"Temperature\") +\n  # Create separate plots per season, arrange all plots in one row, let all scales vary\n  facet_wrap(~season, nrow = 1, scales = \"free\")\n```\n\nIf you would like to group your data based on two variables, you can use `facet_grid()`, separating your two variables with a tilde. However, note that axis limit customization options are more limited with `facet_grid()`, so if you need your axes to vary within columns/rows as well, you can use `facet_wrap()` with the same two-variable argument as well. However, with `facet_wrap()` your faceting variables are \"stuck\" together, which makes the overview of which dimension corresponds to changes in whcih faceting variable less clear.\n\n```{r, eval = FALSE}\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"orangered\", alpha = .3) +\n  labs(x = \"Year\", y = \"Temperature\") +\n  # Arrange plots vertically per year and horizontally per season with facet_grid\n  facet_grid(year~season)\n\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"orangered\", alpha = .3) +\n  labs(x = \"Year\", y = \"Temperature\") +\n  # Same but with facet_wrap\n  facet_wrap(year~season, scales = \"free\")\n```\n\n### Combining independent plots with `patchwork`\n\nIn order to nicely arrange separate plots and same them as a single file, you can use the `patchwork packages`. First you need to save each of your plots into an R object (here `p1`, `p2`, `p3`), then use `+` signs to combine the plots horizontally, and `/` signs to combine them vertically. You can make these layouts as complex as you want to by using parentheses to group rows. Alternatively, you can specify custom layout options, including additional options such as whether to repeat or collect legends, by adding a `plot_layout()` function to the plot objects.\n\n```{r, eval = FALSE}\n# Create and save plots of temp, ozone level and dewpoint over time\n\np1 <- ggplot(chic, aes(x = date, y = temp, color = season)) +\n  geom_point() +\n  labs(x = \"Year\", y = \"Temperature\")\n\np2 <- ggplot(chic, aes(x = date, y = o3, color = season)) +\n  geom_point() +\n  labs(x = \"Year\", y = \"Ozone\")\n\np3 <- ggplot(chic, aes(x = date, y = dewpoint, color = season)) +\n  geom_point() +\n  labs(x = \"Year\", y = \"Dewpoint\")\n\n# Combine temp and ozone horizontally\np1 + p2\n\n# Combine temp and ozone vertically\np1 / p2\n\n# Combine temp and ozone vertically with plot_layout, do not repeat legends\np1 + p2 + plot_layout(ncol = 1, guides = \"collect\")\n\n# Arrange p1 and p2 horizontally on top, p1, p2 and p3 horizontally below\n(p1 + p2) / (p1 + p2 + p3) + plot_layout(guides = \"collect\")\n```\n\nOften it is possible to achieve your desired plot layout both by faceting or with `patchwork`, but depending on your goal and the structure of your data, one approach may be easier than the other. A good rule to keep in mind is that faceting wants data in long format, while `patchwork` often wants wide format: faceting needs a grouping variable that for each observation defines which facet it should go on, while in `patchwork` you can change the aesthetics between plots, so you can easily switch which variables to use per plot.\n\nThe following example shows how we can create the same plots with faceting as with `patchwork` by converting the data to long format where the `name` variable specifies whether the value is the value of temperature, ozone, or dewpoint.\n\n```{r, eval = FALSE}\n# Side-by-side plots of temperature, ozone and dewpoint with facet_wrap\nchic |> \n  # Convert data to long format with variable names to \"name\" and values to \"value\" \n  pivot_longer(c(temp, o3, dewpoint)) |> \n  ggplot(aes(date, value, color = season)) +\n  geom_point() + \n  # Facet by variable name, arrange in one column\n  facet_wrap(~name, ncol = 1)\n```\n\n## Customizing plot elements\n\nSo far we modified the default theme (aka `theme_grey()`) by specifying alternative predefined themes (e.g. `theme_light()`). A way to customize plot elements even further is to change the `theme()` function by redefining particular plot elements.\n\nEvery design element of a plot (panel, grid, axes, text, legend keys, etc.) can be changed with an `element_...()` function (e.g. `element_text()` for text, `element_line()` for lines, `element_blank()` if the element shouldn't be displayed). Each element type has different characteristics you can customize; a few examples are shown here. The help file of the `theme()` functions describes the options in detail.\n\n```{r, eval = FALSE}\nggplot(chic, aes(x = date, y = temp)) +\n  geom_point(color = \"firebrick\") +\n  labs(x = \"Year\", y = \"Temperature (F)\") +\n  # Customize axis title fonts\n  theme(axis.title = element_text(size = 15, color = \"firebrick\", face = \"italic\"),\n        # Remove y-axis ticks\n        axis.ticks.y = element_blank(),\n        # Change minor grid to dashed lines\n        panel.grid.minor = element_line(linetype = \"dashed\"))\n\nggplot(chic, aes(x = date, y = temp, color = season)) +\n  geom_point() +\n  labs(x = \"Year\", y = \"Temperature\", color = \"Season\") +\n  # Move legend to above the plot\n  theme(legend.position = \"top\",\n        # Change legend background color\n        legend.background = element_rect(fill = \"grey90\"),\n        # Remove legend title\n        legend.title = element_blank())\n\nggplot(chic, aes(x = date, y = temp, color = season)) +\n  geom_point() +\n  labs(x = \"Year\", y = \"Temperature\") +\n  # Move legend to coordinates within the plot\n  theme(legend.position = c(0.85, 0.2),\n        # Add whitespace to the left side of the plot\n        plot.margin = margin(l = 50))\n```\n\nIn addition to the `theme()` function there are also other ways to customize legends. You can change what key shape to use by specifying the `key_glyph` within a geom (for the available options of shapes, see [here](https://ggplot2.tidyverse.org/reference/draw_key.html)). You can also add a `guides()` function to your `ggplot` object: some options there overlap with options in `theme()`, but there are also additional arguments such as arranging legend items in multiple rows/columns or specifying the order of legends if there are multiple.\n\n```{r, eval = FALSE}\nggplot(chic, aes(x = date, y = temp, color = season)) +\n  geom_point(key_glyph = \"vline\") +\n  labs(x = \"Year\", y = \"Temperature\") +\n  # Customize the legend further with guide_legend()\n  guides(color = guide_legend(\"Season:\", title.hjust = 0.5, nrow = 2))\n```\n\n## Saving plots\n\nYou can save `ggplot` objects to use outside of the R environment with the `ggsave` function. You can specify an existing `ggplot` object as the first argument, but by default `ggsave()` saves the last plot displayed in your Plots panel. You always need to specify the file path of the saved plot, including the preferred file format (e.g. .png, .jpg, .pdf). You can adjust the plot size with the `scale` argument or by specifying the height and width in your preferred units (the default units are inches).\n\n```{r, eval = FALSE}\nggplot(chic, aes(x = date, y = temp)) + \n  geom_point()\n\n# Save last plot\nggsave(\"figures/plot1.png\", scale = 1.5)\n\np <- ggplot(chic, aes(x = date, y = temp)) + \n  geom_point()\n\n# Save plot saved to the Environment\nggsave(p, \"figures/plot2.png\", height = 10, width = 15, units = \"cm\")\n```\n\n# Other plotting packages and plot types\n\nWhile `ggplot` is extremely flexible and therefore sufficient for most of your plotting needs, it is good to be aware of how to use a few other packages developed for more specific purposes.\n\n## Correlation scatterplot matrix with `GGally`\n\nTo estimate the relationships between a set of (continuous) variables in a dataset, you'd usually calculate a correlation matrix. The `ggpairs()` function from the `GGally` packages presents both this correlation matrix, and plots the distribution of each variable and the relationships for each variable pair. You can adjust the default function e.g. by specifying an additional grouping variable; for more options, see the examples in [*Modern Data Visualization with R*](https://rkabacoff.github.io/datavis/Other.html#scatterplot-matrix).\n\n```{r, eval = FALSE}\nchic |> \n  # Keep only 4 continuous variables\n  select(temp, o3, dewpoint, pm10) |> \n  # Create correlation matrix of the selected variables\n  ggpairs()\n\nchic |> \n  # Keep 4 continuous variables and season as the grouping variable\n  select(temp, o3, dewpoint, pm10, season) |> \n  # Recreate the previous plot but group observations by season\n  # Use only the first 4 columns for the plots (exclude season)\n  ggpairs(columns = 1:4, ggplot2::aes(color = season))\n```\n\n## Pie chart\n\nWhile data scientists do not recommend using pie charts (because humans are quite bad at comparing areas, and better at comparing lengths such as on bar charts), you can nevertheless create pie charts in `ggplot`. In order to do so, you need to create a bar chart, and change the coordinate system to polar coordinates. To make the bars look nice, you should specify your aesthetics and geoms similarly to the example below.\n\n```{r, eval = FALSE}\nchic |> \n  # Get the number of observations per month\n  count(month) |> \n  # Specify y as the counts and fill as the categorical variable\n  ggplot(aes(x = \"\", y = n, fill = month)) +\n  # Create bars with white borders\n  geom_bar(stat = \"identity\", width = 1, color = \"white\") +\n  # Change coordinate system to polar coordinates instead of Cartesian\n  coord_polar(\"y\", start = 0) +\n  # Remove background theme elements\n  theme_void()\n```\n\n## 3-D scatterplot\n\nSimilarly to pie charts, 3-D plots are also discouraged because they are hard to interpret, so use them only if absolutely necessary. In that case, the `scatterplot3d` package contains the `scatterplot3d()` function where you need to specify the variables to put on each axis. Note that this function does not have a separate `data` argument, so you need to specify the variables by extracting the column from the dataframe with the `$` operator.\n\n```{r, eval = FALSE}\n# Create a 3-D scatterplot of temperature, dewpoint and ozone levels\nscatterplot3d(x = chic$temp,\n              y = chic$dewpoint, \n              z = chic$o3)\n```\n\n## Alluvial/Sankey diagrams with `ggalluvial` and `networkD3`\n\nAn interesting plot type is an alluvial diagram, also known as a Sankey diagram. It shows flows between different categories, and is frequently used e.g. to show changes over time in the share of observations belonging to particular groups (e.g. what energy sources households use in 1950 versus in 2000). For demonstration purposes, we'll instead look at how observations per different seasons are split between high and low temperatures (e.g. expecting to see mostly low temperatures in Winter).\n\nIn order to create a static alluvial diagram, you can use the `ggalluvial` package and standard `ggplot` workflows with `alluvium` and `stratum` geoms.\n\n```{r, eval = FALSE}\nchic |> \n  # Redefine temperature as a categorical variable: above mean temperature is high, below is low\n  mutate(temp = ifelse(temp > mean(temp), \"High temp\", \"Low temp\")) |> \n  # Get number of observations per year, season, temp category\n  count(year, season, temp) |> \n  # axis1, axis2, axis3 are the categorical grouping variables, y is the number of observations per group\n  ggplot(aes(axis1 = year, axis2 = season, axis3 = temp, y = n)) +\n  # Create flows, with colors per year\n  geom_alluvium(aes(fill = factor(year))) +\n  # Add rectangles for the categories of each variable\n  geom_stratum() +\n  # Label the rectangles\n  geom_text(stat = \"stratum\", \n            aes(label = after_stat(stratum))) +\n  # Remove background plot elements and legend\n  theme_void() +\n  theme(legend.position = \"none\")\n```\n\nFor an interactive version of the previous plot, you can use the `networkD3` package, however, note that this package requires the input data to have quite a specific format. You need a dataframe of the widths (frequencies/shares) of each link, specifying a numeric identifier for the source and target nodes. In addition, you need a dataframe of nodes that matches the numeric IDs to node names. Once you have both of these dataframes, you can use the `sankeyNetwork()` function. Note that creating the input dataframes gets significantly more complex if the diagram has more than two levels.\n\n(Interactive plots do not display properly on the website.)\n\n```{r, eval = FALSE}\n# Create a tibble of links with 3 variables: source, target, number of observations\nlinks <- chic |> \n  # Redefine temp to hig/low categorical\n  mutate(temp = ifelse(temp > mean(temp), \"High temp\", \"Low temp\")) |> \n  # Number of observations per season-temperature combination\n  count(season, temp)\n\n# Create a tibble of nodes by listing the unique categories in the links tibble\nnodes <- tibble(name = unique(c(links$season, links$temp)))\n\n# Add numerical identifiers of the nodes to the links tibble by using the row index in the nodes tibble \n# Subtract 1 to start the count at 0\nlinks$IDseason <- match(links$season, nodes$name)-1\nlinks$IDtemp <- match(links$temp, nodes$name)-1\n\n# Create an interactive Sankey diagram from the links and nodes tibbles, the numerical category IDs, the observation counts per link and the variable name of the nodes tibble\nsankeyNetwork(Links = links, Nodes = nodes, Source = \"IDseason\",\n              Target = \"IDtemp\", Value = \"n\", NodeID = \"name\")\n```\n\n## Interactive charts with `plotly`\n\nIf you work with interactive documents, you might want to make your plots interactive as well, e.g. by highlighting the data points that a user hovers over. It is very easy to turn `ggplot` objects into interactive plots with the `plotly` package: just save the `ggplot` to an object, and use that object as the argument of the `ggplotly()` function.\n\n(Interactive plots do not display properly on the website.)\n\n```{r, eval = FALSE}\n# Define a simple plot and assign to an object\np <- ggplot(chic, aes(x = date, y = temp, color = season)) +\n  geom_point() +\n  labs(x = \"Year\", y = \"Temperature\")\n\n# Display the plot as an interactive plot \nggplotly(p)\n```\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"visualization.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.555","editor":"visual","theme":"simplex","mainfont":"Cormorant SC","fontsize":"20px","title":"Data Center Apprenticeship:\nData visualization","subtitle":"Spring 2024","date":"Last updated: `r Sys.Date()`","always_allow_html":true},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}