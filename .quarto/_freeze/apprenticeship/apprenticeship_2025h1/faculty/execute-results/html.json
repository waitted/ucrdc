{
  "hash": "9b5851e8c89bb963b6cdab5b3eb585f8",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Faculty workshop: Introduction to R\"\nsubtitle: \"January 2025\" \ndate: \"Last updated: 2025-08-04\"\n---\n\n\n\n\n# Objectives\n\n## Why R?\n\n-   Free and open-source\n-   Reproducible\n-   Widely used in academia and industry; up-to-date with the latest technological developments\n-   Very versatile: extensive package ecosystem for statistics and more\n-   Powerful data wrangling and visualization capabilities\n-   Extensive community support (open-access books, tutorials, forums, AI tools, etc.)\n\n## Why `tidyverse`?\n\n-   Clean, consistent, intuitive, readable syntax for all steps of the data analysis process\n-   Limited set of functions that can be combined in many ways\n-   Many packages beyond core `tidyverse` with the same underlying design, grammar, and data structures, therefore easier to learn advanced techniques\n\n# Introduction to R\n\n## Objects in R\n\nOne of the most basic types of objects in R is a vector. A vector is a collection of values of the same type, such as numbers, characters, or logicals (TRUE/FALSE). You can create a vector with the `c()` function, which stands for concatenate. If you assign a vector to an object with the assignment operator `<-`, your vector will be saved in your environment so you can work with it within your current R session. Some examples of creating vectors are:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nv1 <- c(\"A\", \"B\", \"C\")  # character vector with 3 elements\nv2 <- 25                # numeric vector with 1 element\nv3 <- 1:10              # numeric vector with 10 elements - integers from 1 to 10\n```\n:::\n\n\nTo subset or extract elements from a vector, you can use square brackets `[ ]` with an index. For example, `v1[1]` returns the first element of `v1`, `v3[2:5]` returns the 2nd to 5th elements of `v3`, and `v3[-c(2, 4, 6)]` returns all but the 2nd, 4th and 6th elements of `v3`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nv1[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"A\"\n```\n\n\n:::\n\n```{.r .cell-code}\nv3[2:5]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 3 4 5\n```\n\n\n:::\n\n```{.r .cell-code}\nv3[-c(2, 4, 6)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1  3  5  7  8  9 10\n```\n\n\n:::\n:::\n\n\nA dataframe (or \"tibble\" in `tidyverse`) is a special type of object that combines vectors into a rectangular table. Each column of a dataframe is a vector, and each row is an observation. usually you would load data from an external source, but you can create a dataframe with the `data.frame()` and a tibble with the `tibble()` function. You can also convert other data types such as matrices to tibbles with the `as_tibble()` function. Both functions take vectors as their arguments. Tibbles are preferred because they are more modern and have some convenient features that dataframes don't, but for the most part, differences are minor and for the most part it does not matter whether you work with tibbles or dataframes.\n\nA simple example of creating a tibble is (make sure to load `tidyverse` first):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\n# define vectors within the tibble() function\ntibble(\n  name = c(\"Alice\", \"Bob\", \"Chris\"),\n  height = c(165, 180, 175)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n  name  height\n  <chr>  <dbl>\n1 Alice    165\n2 Bob      180\n3 Chris    175\n```\n\n\n:::\n:::\n\n\n## Functions in R\n\nFunctions are reusable pieces of code that perform a specific task. They take arguments as inputs and return one or more pieces of output. You will mostly work with functions loaded from various packages or from the base R distribution, and in some cases you may write your own functions to avoid repetition or improve the readability of your code. We will cover writing your own functions later in the program.\n\nAs with vectors, the output of a function is saved to your environment only if you assign the result to an object. For example, `sum(x)` will display the sum of the elements of the vector `x`, but `sum <- sum(x)` will save this result to an object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1, 5, 6, 2, 1, 8)\n\nsum(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 23\n```\n\n\n:::\n\n```{.r .cell-code}\nresult <- sum(x)\n```\n:::\n\n\nSome important functions on vectors are\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(x)   # return the mean; add the argument na.rm = TRUE if missing values should be excluded\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.833333\n```\n\n\n:::\n\n```{.r .cell-code}\nlength(x) # give the length of the vector (number of elements)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6\n```\n\n\n:::\n\n```{.r .cell-code}\nunique(x) # list the unique elements of the vector\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 5 6 2 8\n```\n\n\n:::\n:::\n\n\nTo learn more about a function and its arguments, you can use the ? operator or the help() function, for example by typing `?sum` (or equivalently, `?sum()`). It is good practice to request help files from your console and not you R script, since there is no need to save these queries for the future.\n\n# Importing data\n\nR can handle practically any type of data, from simple text files to files used by other (not necessarily open-source) software and complex databases. This gives users a lot of flexibility in terms of data sources and formats.\n\nIn addition to using your own data (e.g. as exported from a survey), the Data Center keeps a continuously updated list of useful datasets by discipline, accessible [here](../../../../tutorials/data).\n\nIn the following, we'll import a CSV file from a URL, but if you want to know more about importing various common file types, follow our more complete [tutorial on importing data](../../../../tutorials/r_adv_import).\n\nWe can use the `read_csv()` function to import a [CSV file](https://github.com/ucrdatacenter/projects/blob/main/apprenticeship/2025h1/student_data.csv) uploaded to the Data Center's GitHub repository. The \"Raw\" button on the GitHub page opens the file in a plain text format, which is the format that `read_csv()` expects. Our data is based on a dataset on student characteristics and grades at a university ([original source](https://www.kaggle.com/datasets/jacksondivakarr/student-classification-dataset?resource=download)). We assign the imported tibble to an object called `data`. *Note:* make sure to load `tidyverse` before proceeding with the rest of the tutorial.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- read_csv(\"https://github.com/ucrdatacenter/projects/raw/refs/heads/main/apprenticeship/2025h1/student_data.csv\")\n```\n:::\n\n\nA few notes regarding importing and exporting data:\n\n-   Always make sure you know your current working directory and the relative path to your data directory. It is better to use relative rather than absolute file paths (i.e. `data/data.csv` instead of `C:/User/Project/data/data.csv`).\n-   Note that if you are using Windows, you may need to replace the backslashes (\\\\) in the file path with forward slashes (/) to avoid errors.\n-   You can import files directly from URLs, although you usually need the URL of a raw file. If a file downloads immediately instead of opening in a raw format, you can try to copy that download link by right-clicking and selecting \"Copy link address\"; the `import()` function from the `rio` package might be successful with those links.\n-   To export data from R, you can almost always use the `write_...()` function corresponding to the desired file format, e.g. `write_csv()`. For Excel files the preferred export function is `write_xlsx()`, and for SPSS's .sav files it is `write_sav()`.\n-   For other file formats, the generic `write()` function is useful; you can specify any file format, and if your input data is readable in the chosen format, the file will export properly.\n-   In all `write_()` functions you need to specify the data you'd like to save and the output file path (absolute or relative) including chosen file extension.\n\n# Data wrangling\n\nData wrangling is the process of cleaning, structuring, and enriching raw data into a more usable format. The `dplyr` package is a part of the `tidyverse` and provides a set of functions that can be combined to perform the most common data wrangling tasks. The package is built around the concept of the \"grammar of data manipulation\", which is a consistent set of verbs that can be combined in many ways to achieve the desired result.\n\nThe main functions in `dplyr` are `filter()`, `select()`, `mutate()`, `arrange()`, `group_by()`, `summarize()`, and `rename()`. `dplyr` also provides a set of functions for combining datasets: `bind_rows()` and `bind_cols()` for row-wise and column-wise binding, and `left_join()`, `right_join()`, `inner_join()`, and `full_join()` for joining datasets based on common variables. These functions can be combined using the pipe operator `|>` (or `%>%`, they are mostly equivalent) to create a data wrangling workflow. The pipe operator takes the output of the function on its left and passes it as the first argument to the function on its right. This allows you to chain multiple functions together in a single line of code, making your code more readable and easier to understand.\n\nIn the following, we'll work with the `data` object imported in the previous section and show how to use the main `dplyr` functions to clean the data so it is suitable for analysis. These steps are useful even if the input data is quite clean, as we often need to work with only a subset of observations/variables, define new variables, or aggregate the data.\n\n## Filtering observations\n\nIf we want to keep only a subset of observations, we can use the `filter()` function. We can specify a logical condition as the argument to `filter()`, and only observations that meet that condition will be kept. For example, to keep only students who are over 21 years old, we can use the following code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(data, age > 21)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 27 × 9\n      id   age sex    scholarship additional_work reading notes listening grade\n   <dbl> <dbl> <chr>        <dbl> <lgl>           <lgl>   <lgl> <lgl>     <dbl>\n 1  5005    22 Male            50 FALSE           TRUE    FALSE TRUE          4\n 2  5015    26 Male            75 TRUE            FALSE   FALSE TRUE          4\n 3  5016    22 Male            50 FALSE           FALSE   TRUE  FALSE         4\n 4  5018    22 Male            50 FALSE           TRUE    FALSE FALSE         4\n 5  5023    22 Male            50 TRUE            TRUE    TRUE  TRUE          3\n 6  5024    25 Male            25 TRUE            TRUE    TRUE  FALSE         4\n 7  5029    24 Male            50 FALSE           FALSE   FALSE FALSE         3\n 8  5032    25 Male            50 TRUE            FALSE   TRUE  FALSE         3\n 9  5040    22 Female          50 FALSE           FALSE   TRUE  TRUE          4\n10  5042    24 Male            50 TRUE            FALSE   TRUE  FALSE         4\n# ℹ 17 more rows\n```\n\n\n:::\n:::\n\n\nWe can also apply logical conditions to character variables, e.g. to keep only students who went to a private high school and who did not receive a failing grade. Filters can be combined with AND (`,` or `&`) and OR (`|`) operators into a single function. Note the use of quotation marks around character values in the logical condition and the double equal sign `==` to denote equality and `!=` for \"not equal\".\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(data, sex == \"Male\", grade != 0) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 87 × 9\n      id   age sex   scholarship additional_work reading notes listening grade\n   <dbl> <dbl> <chr>       <dbl> <lgl>           <lgl>   <lgl> <lgl>     <dbl>\n 1  5001    21 Male           50 TRUE            TRUE    TRUE  FALSE         4\n 2  5002    20 Male           50 TRUE            TRUE    FALSE TRUE          4\n 3  5003    21 Male           50 FALSE           FALSE   FALSE FALSE         4\n 4  5005    22 Male           50 FALSE           TRUE    FALSE TRUE          4\n 5  5006    20 Male           50 FALSE           TRUE    FALSE TRUE          4\n 6  5007    18 Male           75 FALSE           FALSE   TRUE  TRUE          2\n 7  5015    26 Male           75 TRUE            FALSE   FALSE TRUE          4\n 8  5016    22 Male           50 FALSE           FALSE   TRUE  FALSE         4\n 9  5018    22 Male           50 FALSE           TRUE    FALSE FALSE         4\n10  5020    18 Male           50 FALSE           FALSE   FALSE TRUE          3\n# ℹ 77 more rows\n```\n\n\n:::\n:::\n\n\nAnother useful logical operator is `%in%`, which allows you to filter observations based on a list of values. For example, to keep only students who receive either 75% or 100% scholarships, we can use the following code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(data, scholarship %in% c(75, 100))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 65 × 9\n      id   age sex    scholarship additional_work reading notes listening grade\n   <dbl> <dbl> <chr>        <dbl> <lgl>           <lgl>   <lgl> <lgl>     <dbl>\n 1  5007    18 Male            75 FALSE           FALSE   TRUE  TRUE          2\n 2  5012    18 Female          75 TRUE            FALSE   TRUE  FALSE         0\n 3  5013    18 Female          75 FALSE           TRUE    FALSE FALSE         0\n 4  5014    19 Female         100 FALSE           TRUE    FALSE FALSE         4\n 5  5015    26 Male            75 TRUE            FALSE   FALSE TRUE          4\n 6  5017    18 Female         100 FALSE           TRUE    FALSE FALSE         4\n 7  5019    18 Female          75 FALSE           TRUE    FALSE FALSE         4\n 8  5021    18 Male           100 TRUE            FALSE   FALSE TRUE          4\n 9  5022    18 Male           100 FALSE           FALSE   FALSE FALSE         4\n10  5030    19 Male            75 FALSE           FALSE   FALSE TRUE          2\n# ℹ 55 more rows\n```\n\n\n:::\n:::\n\n\n## Selecting variables\n\nIf we want to keep only a subset of variables, we can use the `select()` function. We can specify the variables we want to keep (or exclude, with `-` signs) as the arguments to `select()`, and only those variables will be kept. For example, to keep only the `Id` and `Student_Age` variables, we can use the following code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(data, id, age)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 145 × 2\n      id   age\n   <dbl> <dbl>\n 1  5001    21\n 2  5002    20\n 3  5003    21\n 4  5004    18\n 5  5005    22\n 6  5006    20\n 7  5007    18\n 8  5008    18\n 9  5009    19\n10  5010    21\n# ℹ 135 more rows\n```\n\n\n:::\n:::\n\n\nWe can also select columns based on their location in the tibble or by looking for patterns in the column names:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(data, id:sex) # select a range of columns\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 145 × 3\n      id   age sex   \n   <dbl> <dbl> <chr> \n 1  5001    21 Male  \n 2  5002    20 Male  \n 3  5003    21 Male  \n 4  5004    18 Female\n 5  5005    22 Male  \n 6  5006    20 Male  \n 7  5007    18 Male  \n 8  5008    18 Female\n 9  5009    19 Female\n10  5010    21 Female\n# ℹ 135 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\nselect(data, starts_with(\"a\")) # select columns that start with \"a\"\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 145 × 2\n     age additional_work\n   <dbl> <lgl>          \n 1    21 TRUE           \n 2    20 TRUE           \n 3    21 FALSE          \n 4    18 TRUE           \n 5    22 FALSE          \n 6    20 FALSE          \n 7    18 FALSE          \n 8    18 TRUE           \n 9    19 FALSE          \n10    21 FALSE          \n# ℹ 135 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\nselect(data, -grade) # keep everything but \"grade\"\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 145 × 8\n      id   age sex    scholarship additional_work reading notes listening\n   <dbl> <dbl> <chr>        <dbl> <lgl>           <lgl>   <lgl> <lgl>    \n 1  5001    21 Male            50 TRUE            TRUE    TRUE  FALSE    \n 2  5002    20 Male            50 TRUE            TRUE    FALSE TRUE     \n 3  5003    21 Male            50 FALSE           FALSE   FALSE FALSE    \n 4  5004    18 Female          50 TRUE            FALSE   TRUE  FALSE    \n 5  5005    22 Male            50 FALSE           TRUE    FALSE TRUE     \n 6  5006    20 Male            50 FALSE           TRUE    FALSE TRUE     \n 7  5007    18 Male            75 FALSE           FALSE   TRUE  TRUE     \n 8  5008    18 Female          50 TRUE            FALSE   TRUE  TRUE     \n 9  5009    19 Female          50 FALSE           FALSE   FALSE FALSE    \n10  5010    21 Female          50 FALSE           FALSE   TRUE  FALSE    \n# ℹ 135 more rows\n```\n\n\n:::\n:::\n\n\nA pipe workflow allows us to combine the filtering and selecting operations into a single, step-by-step workflow:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata |> \n  filter(age > 21) |> \n  select(id, age)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 27 × 2\n      id   age\n   <dbl> <dbl>\n 1  5005    22\n 2  5015    26\n 3  5016    22\n 4  5018    22\n 5  5023    22\n 6  5024    25\n 7  5029    24\n 8  5032    25\n 9  5040    22\n10  5042    24\n# ℹ 17 more rows\n```\n\n\n:::\n:::\n\n\n## Creating new variables\n\nIf we want to create a new variable based on existing variables, we can use the `mutate()` function. We can specify the new variable name and the calculation for the new variable as the arguments to `mutate()`, and the new variable will be added to the dataset. For example, we can create a new variable `participation`, which is `TRUE` if the student does the assigned reading *and* listens in class *and* takes notes. We create this variable using a logical expression, using a simplified notation (i.e. not write out `reading == TRUE`, as doing so is not necessary for logical variables). Andother variable, `scholarship_decimal`, is created by dividing the `Scholarship` variable by 100 to get a variable that represents the value of scholarship as a fraction of total cost.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata |> \n  # create new variables\n  mutate(participation = reading & notes & listening,\n         scholarship_decimal = scholarship / 100) |> \n  # keep only new variables and student id\n  select(id, participation, scholarship_decimal)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 145 × 3\n      id participation scholarship_decimal\n   <dbl> <lgl>                       <dbl>\n 1  5001 FALSE                        0.5 \n 2  5002 FALSE                        0.5 \n 3  5003 FALSE                        0.5 \n 4  5004 FALSE                        0.5 \n 5  5005 FALSE                        0.5 \n 6  5006 FALSE                        0.5 \n 7  5007 FALSE                        0.75\n 8  5008 FALSE                        0.5 \n 9  5009 FALSE                        0.5 \n10  5010 FALSE                        0.5 \n# ℹ 135 more rows\n```\n\n\n:::\n:::\n\n\n## Categorical variables as factors\n\nIt is often useful to clearly define the levels of a categorical variable, especially if these levels have a meaningful ordering. For unordered categories, R provides the data type `factor`, while for ordered variables the relevant data type is `ordered`. Factor and ordered values appear as character strings when viewed, but are treated as numbers with labels internally, which makes it easier to show descriptives of the variable and include it in models. For example, we can define `sex` as a factor with two levels. If we don't specify the levels of the factor explicitly, then the levels will be sorted alphabetically.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata |> \n  mutate(sex = factor(sex)) |> \n  # view variable types and levels by looking at the structure of the data\n  str()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntibble [145 × 9] (S3: tbl_df/tbl/data.frame)\n $ id             : num [1:145] 5001 5002 5003 5004 5005 ...\n $ age            : num [1:145] 21 20 21 18 22 20 18 18 19 21 ...\n $ sex            : Factor w/ 2 levels \"Female\",\"Male\": 2 2 2 1 2 2 2 1 1 1 ...\n $ scholarship    : num [1:145] 50 50 50 50 50 50 75 50 50 50 ...\n $ additional_work: logi [1:145] TRUE TRUE FALSE TRUE FALSE FALSE ...\n $ reading        : logi [1:145] TRUE TRUE FALSE FALSE TRUE TRUE ...\n $ notes          : logi [1:145] TRUE FALSE FALSE TRUE FALSE FALSE ...\n $ listening      : logi [1:145] FALSE TRUE FALSE FALSE TRUE TRUE ...\n $ grade          : num [1:145] 4 4 4 4 4 4 2 4 2 0 ...\n```\n\n\n:::\n:::\n\n\n## Data cleaning as a single pipeline\n\nUntil now we didn't save any of our data wrangling steps as new objects, so the original `data` object is still unchanged. If we want to save the cleaned data as a new object, we can assign the result of the pipe workflow to a new object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_subset <- data |> \n  filter(age > 21) |> \n  mutate(sex = factor(sex)) |> \n  select(id, age, sex)\n```\n:::\n\n\n# Data visualization\n\n## The logic of `ggplot2`\n\nThe `ggplot2` package builds up figures in layers, by adding elements one at a time. You always start with a base `ggplot` where you specify the data used by the plot and possibly the variables to place on each axis. These variables are specified within an `aes()` function, which stands for aesthetics.\n\nThe `ggplot()` function in itself only creates a blank canvas; we need to add so-called geoms to actually plot the data. You can choose from a wide range of geoms, and also use multiple geoms in one plot. You can add elements to a `ggplot` objects with the `+` sign. You should think of the `+` sign in `ggplot` workflows in the same way you think of the pipe operators in data wrangling workflows.\n\n## Univariate plots\n\nYou can plot a single continuous variable with a histogram, a density plot, or a boxplot. Other than the name of the dataset and the variable, no additional arguments need to be specified; but you can customize the plot by adding arguments to the `geom_` functions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# binwidth or bins determine the number of bins\n# with binwidth = 1, each bin is 1 year wide\nggplot(data, aes(x = age)) +\n  geom_histogram(binwidth = 1, color = \"black\", fill = \"lightblue\")\n```\n\n::: {.cell-output-display}\n![](faculty_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n\n```{.r .cell-code}\nggplot(data, aes(x = age)) +\n  geom_density(fill = \"lightblue\", alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](faculty_files/figure-html/unnamed-chunk-16-2.png){width=672}\n:::\n\n```{.r .cell-code}\nggplot(data, aes(x = age)) +\n  geom_boxplot()\n```\n\n::: {.cell-output-display}\n![](faculty_files/figure-html/unnamed-chunk-16-3.png){width=672}\n:::\n:::\n\n\nTo compare the frequencies of discrete variables, you can use a bar plot.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data, aes(x = additional_work)) +\n  geom_bar()\n```\n\n::: {.cell-output-display}\n![](faculty_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n## Bivariate plots\n\nYou can plot two continuous variables with a scatter plot. For example, you can plot the relationship between age and grade by specifying these variables as the x and y aesthetics:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data, aes(x = age, y = grade)) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](faculty_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\nFitting a smooth curve or a linear regression line to the scatter plot can help you see the overall trend in the data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data, aes(x = age, y = grade)) +\n  geom_point() + \n  geom_smooth()\n```\n\n::: {.cell-output-display}\n![](faculty_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n\n```{.r .cell-code}\nggplot(data, aes(x = age, y = grade)) +\n  geom_point() + \n  # method = \"lm\" fits a linear model, se = FALSE removes the confidence interval\n  geom_smooth(method = \"lm\", se = FALSE)\n```\n\n::: {.cell-output-display}\n![](faculty_files/figure-html/unnamed-chunk-19-2.png){width=672}\n:::\n:::\n\n\nIf points overlap a lot, it might be useful to add some jitter, i.e. random noise to distribute the points, by using `geom_jitter()` instead of `geom_point()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data, aes(x = age, y = grade)) +\n  geom_jitter() + \n  geom_smooth(method = \"lm\", se = FALSE)\n```\n\n::: {.cell-output-display}\n![](faculty_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\nCategorical variables can be used to show the distribution of continuous variables by group. You can put a categorical variable on one of the axes, or use it on another aesthetic, such as the fill or color. Note that if a variable determines the fill, the color, and the shape of the points, that has to be specified inside an `aes()` function, while if the characteristic is pre-defined, then it goes outside the `aes()` function. Also note that if you specify aesthetics in the main `ggplot()` function, then they apply to all geoms, while if you specify them in a `geom_...()` function, they apply only to that geom.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data, aes(x = grade, y = additional_work)) +\n  geom_boxplot()\n```\n\n::: {.cell-output-display}\n![](faculty_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n\n```{.r .cell-code}\nggplot(data) +\n  geom_density(aes(x = grade, fill = additional_work), alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](faculty_files/figure-html/unnamed-chunk-21-2.png){width=672}\n:::\n:::\n\n\nTo plot two categorical variables, you can use a bar plot with an extra grouping argument specifying the fill of the bars. The next plot shows the number of students who do the class readings or not, and for each group we know whether they work take notes in class or not.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data, aes(x = reading, fill = notes)) +\n  geom_bar()\n```\n\n::: {.cell-output-display}\n![](faculty_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# to put the bars next to each other instead of on top, specify the position\nggplot(data, aes(x = reading, fill = notes)) +\n  geom_bar(position = \"dodge\")\n```\n\n::: {.cell-output-display}\n![](faculty_files/figure-html/unnamed-chunk-22-2.png){width=672}\n:::\n:::\n\n\n## Customizing plot features\n\nThe two largest advantages of `ggplot2` are the ability to layer multiple geoms on top of each other and the ability to extensively customize every plot by adding additional plot elements.\n\nYou can make the plot more informative by adding titles and axis labels.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data, aes(x = grade, y = reading)) +\n  geom_boxplot() +\n  labs(title = \"Grade distribution based on whether the student does the reading\",\n       x = \"Grade\",\n       y = \"Student does the reading?\")\n```\n\n::: {.cell-output-display}\n![](faculty_files/figure-html/unnamed-chunk-23-1.png){width=672}\n:::\n:::\n\n\nYou can also change the appearance of the plot by changing the theme, the color palette, and the axis scales.\n\nYou can set the theme of the plot with one of the `theme_...()` functions, or set the theme for the entire R session with `theme_set()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data, aes(x = grade, y = reading)) +\n  geom_boxplot() +\n  labs(title = \"Grade distribution based on whether the student does the reading\",\n       x = \"Grade\",\n       y = \"Student does the reading?\") +\n  # set the theme of this plot to the pre-defined theme_light\n  theme_light()\n```\n\n::: {.cell-output-display}\n![](faculty_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# set the theme of all future plots to the pre-defined theme_minimal\ntheme_set(theme_minimal())\n```\n:::\n\n\nYou can adjust the axis breaks and labels with the `scale_x_...()` and `scale_y_...()` functions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data, aes(x = grade, y = reading)) +\n  geom_boxplot() +\n  labs(title = \"Grade distribution based on whether the student does the reading\",\n       x = \"Grade\",\n       y = \"Student does the reading?\") +\n  # define the axis tick positions on the continuous x axis\n  scale_x_continuous(breaks = seq(0, 4, 0.5)) +\n  # relabel the items on the discrete y axis\n  scale_y_discrete(breaks = c(FALSE, TRUE), labels = c(\"No\", \"Yes\"))\n```\n\n::: {.cell-output-display}\n![](faculty_files/figure-html/unnamed-chunk-25-1.png){width=672}\n:::\n:::\n\n\n## More advanced features\n\nThe [R Graph Gallery](https://r-graph-gallery.com/) provides a long list of common plot types, and so do Chapters 4 and 5 of [*Modern Data Visualization with R*](https://rkabacoff.github.io/datavis/index.html). Both resources group geoms by the type of variable(s) plotted.\n\n## Saving plots\n\nYou can save `ggplot` objects to use outside of the R environment with the `ggsave` function. By default `ggsave()` saves the last plot displayed in your Plots panel. You always need to specify the file path of the saved plot, including the preferred file format (e.g. .png, .jpg, .pdf).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data, aes(x = grade, y = age)) + \n  geom_point()\n\n# Save last plot\nggsave(\"figures/plot1.png\", scale = 1.5)\n```\n:::\n\n\n# Summary statistics\n\n## Summaries in the console\n\nIn the R console, the `summary()` function provides a quick overview of the data, showing the minimum, 1st quartile, median, mean, 3rd quartile, and maximum of each numerical variable, and levels for factors. The `count()` function provides a tibble of frequencies for any number of variables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       id            age            sex             scholarship    \n Min.   :5001   Min.   :18.00   Length:145         Min.   : 25.00  \n 1st Qu.:5037   1st Qu.:18.00   Class :character   1st Qu.: 50.00  \n Median :5073   Median :19.00   Mode  :character   Median : 50.00  \n Mean   :5073   Mean   :19.68                      Mean   : 64.76  \n 3rd Qu.:5109   3rd Qu.:21.00                      3rd Qu.: 75.00  \n Max.   :5145   Max.   :26.00                      Max.   :100.00  \n                                                   NA's   :1       \n additional_work  reading          notes         listening      \n Mode :logical   Mode :logical   Mode :logical   Mode :logical  \n FALSE:96        FALSE:76        FALSE:68        FALSE:70       \n TRUE :49        TRUE :69        TRUE :77        TRUE :75       \n                                                                \n                                                                \n                                                                \n                                                                \n     grade      \n Min.   :0.000  \n 1st Qu.:1.500  \n Median :3.000  \n Mean   :2.755  \n 3rd Qu.:4.000  \n Max.   :4.000  \n                \n```\n\n\n:::\n\n```{.r .cell-code}\ncount(data, sex, scholarship)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 8 × 3\n  sex    scholarship     n\n  <chr>        <dbl> <int>\n1 Female          50    26\n2 Female          75    19\n3 Female         100    13\n4 Male            25     3\n5 Male            50    50\n6 Male            75    23\n7 Male           100    10\n8 Male            NA     1\n```\n\n\n:::\n:::\n\n\n## Export-ready summary tables\n\nThe `gtsummary` package provides a more customizable way to create tables for publication with the `tbl_summary()` function. In addition, the `gtsave()` function from the `gt` package allows you to save the table in a variety of formats, including as a Word or TeX file. Make sure to install and load the `gtsummary` and `gt` packages before using them.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# install.packages(\"gtsummary\")\n# install.packages(\"gt\")\nlibrary(gtsummary)\nlibrary(gt)\n\n# create a summary table of the data\ntbl_summary(data)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# the by argument allows for stratification by a variable\ntbl_summary(data, by = sex) |> \n  # convert to gt object for export\n  as_gt() |>\n  # export table as a Word file\n  gtsave(\"summary_table.docx\")\n```\n:::\n\n\n# Hypothesis testing\n\nMost of the simple statistical tests are from base R, so they don't rely on tidy principles, but many are compatible with tidy workflows to at least some extent. Most of them use a formula interface, where the dependent variable is on the left side of the tilde `~` and the independent variable(s) on the right side.\n\nFor example, a two-sided t-test requires a continuous dependent variable and a categorical independent variable inside the `t.test()` function. Similarly, the `lm()` function for linear regressions allows for multiple independent variables and automatically converts characters and factors to dummy variables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# two-sided t-test for grade differences based on doing the reading\nt.test(grade ~ reading, data = data)\n\n# linear regression for grade based on age, scholarship, and doing the reading\nlm(grade ~ age + scholarship + reading, data = data)\n\n# linear regression based on all variables in the data\nlm(grade ~ ., data = data)\n```\n:::\n\n\nTo get more detailed information about the results of a hypothesis test, we can assign the result to an object and use the `summary()` function to get the full output. In addition, the `tbl_regression()` function from the `gtsummary` package provides a publication-ready regression table.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit <- lm(grade ~ ., data = data)\nsummary(fit)\ntbl_regression(fit)\n```\n:::\n",
    "supporting": [
      "faculty_files\\figure-html"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}