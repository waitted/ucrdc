{
  "hash": "7d6a5083044e3ff562908177d0b5af44",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Data Center Apprenticeship:\\nR basics: Hypothesis testing / modelling\"\nsubtitle: \"June 2024\" \ndate: \"Last updated: 2025-08-09\"\n---\n\n\n\n::: {.cell}\n\n:::\n\n\nMost of the simple statistical tests are from base R, so they don't rely on tidy principles, but many are compatible with tidy workflows to at least some extent. In the following we'll cover some of the key methods that show up in methods and statistics courses at UCR. In addition, the `tidy()` function from the `broom` package converts most text output into simple tibblesy, which are useful for exporting and visualizing results.\n\n# t-tests\n\nWe can run one and two samples t-tests to evaluate group means with the `t.test()` function. The function supports various options and model specifications: a simple one-sample t-test only requires specifying the variable of interest, either with `x = data$variable` or `x = variable, data = data` syntax. For two-sample t-tests, we can use the formula syntax `y ~ x` to specify the dependent and independent variables or the `x` and `y` (and optionally `data`) arguments. Additional options include specifying the alternative hypothesis, the confidence level, the value of $\\mu$, and whether we want a paired t-test and assume equal variances. Helper functions such as `tidy()` convert the Console output to an easy-to-export tibble of results.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(broom) # for tidy() function\n\n# simple t-test (H0: mean=mu)\nt.test(data$scholarship, mu = 50)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tOne Sample t-test\n\ndata:  data$scholarship\nt = 9.0903, df = 143, p-value = 7.493e-16\nalternative hypothesis: true mean is not equal to 50\n95 percent confidence interval:\n 61.54805 67.96584\nsample estimates:\nmean of x \n 64.75694 \n```\n\n\n:::\n\n```{.r .cell-code}\n# use data argument instead of data$... to work in pipe workflows\ndata |> \n  # grade ~ reading is formula specification: variable ~ group\n  # _ is placeholder if the pipe input is not the first argument of the next function\n  t.test(grade ~ reading, alternative = \"greater\", data = _)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tWelch Two Sample t-test\n\ndata:  grade by reading\nt = -2.1671, df = 142.85, p-value = 0.9841\nalternative hypothesis: true difference in means between group FALSE and group TRUE is greater than 0\n95 percent confidence interval:\n -0.7995718        Inf\nsample estimates:\nmean in group FALSE  mean in group TRUE \n           2.539474            2.992754 \n```\n\n\n:::\n\n```{.r .cell-code}\ndata |> \n  t.test(grade ~ reading, alternative = \"greater\", data = _) |> \n  tidy()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 10\n  estimate estimate1 estimate2 statistic p.value parameter conf.low conf.high\n     <dbl>     <dbl>     <dbl>     <dbl>   <dbl>     <dbl>    <dbl>     <dbl>\n1   -0.453      2.54      2.99     -2.17   0.984      143.   -0.800       Inf\n# ℹ 2 more variables: method <chr>, alternative <chr>\n```\n\n\n:::\n:::\n\n\n# Correlation test\n\nThe `cor.test()` function calculates the correlation between two variables. Again, the function supports various specifications: `x` and `y` arguments, formula syntax (see below for an example), and the `data` argument.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncor.test( ~ grade + age, data = data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tPearson's product-moment correlation\n\ndata:  grade and age\nt = 2.2587, df = 143, p-value = 0.02541\nalternative hypothesis: true correlation is not equal to 0\n95 percent confidence interval:\n 0.02329811 0.33837421\nsample estimates:\n      cor \n0.1856025 \n```\n\n\n:::\n\n```{.r .cell-code}\n# assign the outcome to an object\ncor_result <- cor.test( ~ grade + age, data = data)\n# tibble of results\ntidy(cor_result)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 8\n  estimate statistic p.value parameter conf.low conf.high method     alternative\n     <dbl>     <dbl>   <dbl>     <int>    <dbl>     <dbl> <chr>      <chr>      \n1    0.186      2.26  0.0254       143   0.0233     0.338 Pearson's… two.sided  \n```\n\n\n:::\n:::\n\n\n# Simple regression\n\nA key building block of statistical analysis is linear regression. The `lm()` function fits a linear model to the data, with a wide range of specifications, passed as the formula argument (first argument if unnamed). The formula syntax is `y ~ x`, where `y` is the dependent variable and `x` is the independent variable. Again, optional function arguments allow for a lot of customization, but the default settings are sufficient for most applications. Helper functions such as `tidy()` and `summary()` provide extensive summaries of the model fit and coefficients, and `stargazer()` creates neat tables of the results. Assigning the result of a model to an object saves computational time, as then we can work with the results without having to re-run the analysis every time.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# assign outcome to object\nfit <- lm(grade ~ age, data = data)\n\n# extensive result summary\nfit |> summary()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = grade ~ age, data = data)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-2.9125 -1.0542  0.3264  1.0875  1.4458 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)  \n(Intercept)  0.40464    1.04592   0.387   0.6994  \nage          0.11942    0.05287   2.259   0.0254 *\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 1.264 on 143 degrees of freedom\nMultiple R-squared:  0.03445,\tAdjusted R-squared:  0.0277 \nF-statistic: 5.102 on 1 and 143 DF,  p-value: 0.02541\n```\n\n\n:::\n\n```{.r .cell-code}\n# tidy coefficients\nfit |> tidy()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 5\n  term        estimate std.error statistic p.value\n  <chr>          <dbl>     <dbl>     <dbl>   <dbl>\n1 (Intercept)    0.405    1.05       0.387  0.699 \n2 age            0.119    0.0529     2.26   0.0254\n```\n\n\n:::\n\n```{.r .cell-code}\n# display-ready table\nfit |> \n  stargazer(type = \"text\", title = \"Grade - agre regression results\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nGrade - agre regression results\n===============================================\n                        Dependent variable:    \n                    ---------------------------\n                               grade           \n-----------------------------------------------\nage                           0.119**          \n                              (0.053)          \n                                               \nConstant                       0.405           \n                              (1.046)          \n                                               \n-----------------------------------------------\nObservations                    145            \nR2                             0.034           \nAdjusted R2                    0.028           \nResidual Std. Error      1.264 (df = 143)      \nF Statistic            5.102** (df = 1; 143)   \n===============================================\nNote:               *p<0.1; **p<0.05; ***p<0.01\n```\n\n\n:::\n:::\n\n\n# Multiple regression\n\nMultiple regression extends simple regression to multiple independent variables. The only difference is the formula specification, which now connects multiple independent variables with `+` signs. The formula specification also allows for interactions between variables, which can be specified with `*` (if the main effects should be included) or `:` (for only the interaction term). The `DV ~ .~` syntax includes all variables in the data except the dependent variable as independent variables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlm(grade ~ age + scholarship, data = data) |> summary()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = grade ~ age + scholarship, data = data)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-2.8845 -1.0609  0.3735  1.1478  1.5025 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)  \n(Intercept) 0.048581   1.292374   0.038    0.970  \nage         0.129004   0.056549   2.281    0.024 *\nscholarship 0.002536   0.005788   0.438    0.662  \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 1.271 on 141 degrees of freedom\n  (1 observation deleted due to missingness)\nMultiple R-squared:  0.03636,\tAdjusted R-squared:  0.0227 \nF-statistic:  2.66 on 2 and 141 DF,  p-value: 0.07343\n```\n\n\n:::\n\n```{.r .cell-code}\n# all variables in data\nlm(grade ~ ., data = data) |> summary()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = grade ~ ., data = data)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-3.5165 -0.9030  0.2786  0.9096  2.1809 \n\nCoefficients:\n                     Estimate Std. Error t value Pr(>|t|)   \n(Intercept)         45.780346  14.038274   3.261  0.00141 **\nid                  -0.009043   0.002749  -3.290  0.00128 **\nage                  0.128874   0.056319   2.288  0.02367 * \nsexMale             -0.517980   0.230416  -2.248  0.02620 * \nscholarship          0.005147   0.005825   0.883  0.37855   \nadditional_workTRUE -0.041568   0.231178  -0.180  0.85757   \nreadingTRUE          0.361383   0.206867   1.747  0.08292 . \nnotesTRUE            0.011816   0.210672   0.056  0.95536   \nlisteningTRUE        0.225988   0.209844   1.077  0.28343   \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 1.218 on 135 degrees of freedom\n  (1 observation deleted due to missingness)\nMultiple R-squared:  0.1525,\tAdjusted R-squared:  0.1023 \nF-statistic: 3.037 on 8 and 135 DF,  p-value: 0.003596\n```\n\n\n:::\n\n```{.r .cell-code}\n# interactions\nlm(grade ~ age * scholarship, data = data) |> summary()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = grade ~ age * scholarship, data = data)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-2.8931 -1.0857  0.2747  1.1853  1.5539 \n\nCoefficients:\n                 Estimate Std. Error t value Pr(>|t|)\n(Intercept)     -2.554899   3.814695  -0.670    0.504\nage              0.262316   0.192274   1.364    0.175\nscholarship      0.046368   0.060690   0.764    0.446\nage:scholarship -0.002266   0.003123  -0.726    0.469\n\nResidual standard error: 1.273 on 140 degrees of freedom\n  (1 observation deleted due to missingness)\nMultiple R-squared:  0.03997,\tAdjusted R-squared:  0.0194 \nF-statistic: 1.943 on 3 and 140 DF,  p-value: 0.1254\n```\n\n\n:::\n:::\n\n\n# ANOVA\n\nAnalysis of variance (ANOVA) is a generalization of the t-test to multiple groups. The `aov()` function fits an ANOVA model to the data, with the formula syntax `y ~ x`, where `y` is the dependent variable and `x` is the independent variable. The same helper functions as with `lm()` can be used to summarize the results.\n\nNote that ANOVA is a specific case of a linear regression model, so the results are equivalent to those of a linear regression model with a categorical independent variable.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nanova_fit <- aov(grade ~ reading, data = data)\n\nsummary(anova_fit)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n             Df Sum Sq Mean Sq F value Pr(>F)  \nreading       1   7.43   7.431   4.638  0.033 *\nResiduals   143 229.13   1.602                 \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n\n\n:::\n\n```{.r .cell-code}\ntidy(anova_fit)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 6\n  term         df  sumsq meansq statistic p.value\n  <chr>     <dbl>  <dbl>  <dbl>     <dbl>   <dbl>\n1 reading       1   7.43   7.43      4.64  0.0330\n2 Residuals   143 229.     1.60     NA    NA     \n```\n\n\n:::\n\n```{.r .cell-code}\n# equivalent regression\nlm(grade ~ reading, data = data) |> summary()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = grade ~ reading, data = data)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-2.9928 -1.0395  0.4605  1.0072  1.4605 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)    \n(Intercept)   2.5395     0.1452  17.490   <2e-16 ***\nreadingTRUE   0.4533     0.2105   2.153    0.033 *  \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 1.266 on 143 degrees of freedom\nMultiple R-squared:  0.03141,\tAdjusted R-squared:  0.02464 \nF-statistic: 4.638 on 1 and 143 DF,  p-value: 0.03296\n```\n\n\n:::\n:::\n\n\n# Chi-square test\n\nThe chi-square test is used to test the independence of two categorical variables. The `chisq.test()` function calculates the chi-square statistic and the p-value for the test. Unlike the previous functions, the function does not allow for a `data` argument, and is therefore difficult to implement in tidy workflows.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nchisq.test(data$reading, data$notes)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tPearson's Chi-squared test with Yates' continuity correction\n\ndata:  data$reading and data$notes\nX-squared = 0.14464, df = 1, p-value = 0.7037\n```\n\n\n:::\n:::\n\n\nAdd contingency tables:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# with table()\ntable(data$reading, data$notes)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       \n        FALSE TRUE\n  FALSE    34   42\n  TRUE     34   35\n```\n\n\n:::\n\n```{.r .cell-code}\n# with xtabs()\nxtabs(~ reading + notes, data = data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       notes\nreading FALSE TRUE\n  FALSE    34   42\n  TRUE     34   35\n```\n\n\n:::\n\n```{.r .cell-code}\n# with count() and pivot_wider()\ndata |> \n  count(reading, notes) |>\n  pivot_wider(names_from = notes, values_from = n, values_fill = 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 3\n  reading `FALSE` `TRUE`\n  <lgl>     <int>  <int>\n1 FALSE        34     42\n2 TRUE         34     35\n```\n\n\n:::\n\n```{.r .cell-code}\n# proportions with table() and prop.table()\ntable(data$reading, data$notes) |> prop.table()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       \n            FALSE      TRUE\n  FALSE 0.2344828 0.2896552\n  TRUE  0.2344828 0.2413793\n```\n\n\n:::\n\n```{.r .cell-code}\n# proportions with count() and pivot_wider()\ndata |> \n  count(reading, notes) |>\n  mutate(prop = n / sum(n)) |>\n  select(-n) |> \n  pivot_wider(names_from = notes, values_from = prop, values_fill = 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 3\n  reading `FALSE` `TRUE`\n  <lgl>     <dbl>  <dbl>\n1 FALSE     0.234  0.290\n2 TRUE      0.234  0.241\n```\n\n\n:::\n:::\n\n\n# Logistic regression\n\nWhen it comes to predicting binary outcomes, linear regression has some problems, such as predicting values outside the 0-1 range. Therefore in those cases, we often use logistic regression instead. The `glm()` function fits a logistic regression model to the data. Other than the `family` argument, which specifies the distribution of the dependent variable, the function works in the same as `lm()`. A logistic regression uses `family = \"binomial\"`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlogit_fit <- glm(reading ~ age, data = data, family = \"binomial\")\n\nlogit_fit |> summary()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nglm(formula = reading ~ age, family = \"binomial\", data = data)\n\nCoefficients:\n             Estimate Std. Error z value Pr(>|z|)\n(Intercept) -0.219462   1.656757  -0.132    0.895\nage          0.006241   0.083743   0.075    0.941\n\n(Dispersion parameter for binomial family taken to be 1)\n\n    Null deviance: 200.67  on 144  degrees of freedom\nResidual deviance: 200.67  on 143  degrees of freedom\nAIC: 204.67\n\nNumber of Fisher Scoring iterations: 3\n```\n\n\n:::\n\n```{.r .cell-code}\nlogit_fit |> tidy()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 5\n  term        estimate std.error statistic p.value\n  <chr>          <dbl>     <dbl>     <dbl>   <dbl>\n1 (Intercept) -0.219      1.66     -0.132    0.895\n2 age          0.00624    0.0837    0.0745   0.941\n```\n\n\n:::\n\n```{.r .cell-code}\n# display-ready table\nstargazer(logit_fit, type = \"text\", \n          title = \"Relationship between doing the reading and age\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nRelationship between doing the reading and age\n=============================================\n                      Dependent variable:    \n                  ---------------------------\n                            reading          \n---------------------------------------------\nage                          0.006           \n                            (0.084)          \n                                             \nConstant                    -0.219           \n                            (1.657)          \n                                             \n---------------------------------------------\nObservations                  145            \nLog Likelihood             -100.335          \nAkaike Inf. Crit.           204.669          \n=============================================\nNote:             *p<0.1; **p<0.05; ***p<0.01\n```\n\n\n:::\n:::\n\n\n# Non-parametric tests\n\nNon-parametric tests are used when the assumptions of parametric tests are violated. Running them in R follows the same structure as running the parametric alternative, other than the function name itself and potential alternative optional arguments.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Wilcoxon signed-rank test\nwilcox.test(data$grade, mu = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tWilcoxon signed rank test with continuity correction\n\ndata:  data$grade\nV = 6767.5, p-value = 1.238e-10\nalternative hypothesis: true location is not equal to 2\n```\n\n\n:::\n\n```{.r .cell-code}\n# Mann-Whitney U test\nwilcox.test(grade ~ reading, data = data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tWilcoxon rank sum test with continuity correction\n\ndata:  grade by reading\nW = 2119, p-value = 0.03795\nalternative hypothesis: true location shift is not equal to 0\n```\n\n\n:::\n\n```{.r .cell-code}\n# Kruskal-Wallis test (scholarship is a number in the data so convert to factor for this example)\nkruskal.test(grade ~ factor(scholarship), data = data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tKruskal-Wallis rank sum test\n\ndata:  grade by factor(scholarship)\nKruskal-Wallis chi-squared = 20.368, df = 3, p-value = 0.0001424\n```\n\n\n:::\n:::\n\n\n# PCA and factor analysis\n\nPrincipal component analysis (PCA) and factor analysis are used to reduce the dimensionality of a dataset. The `prcomp()` function fits a PCA model to the data, and the `factanal()` function fits a factor analysis model. Both functions work with the formula syntax, and the `data` argument can be used to specify the data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# PCA\npca_fit <- prcomp(~ grade + age + scholarship, data = data)\n\n# summary of PCA\nsummary(pca_fit)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nImportance of components:\n                           PC1     PC2     PC3\nStandard deviation     19.4919 1.90658 1.24411\nProportion of Variance  0.9865 0.00944 0.00402\nCumulative Proportion   0.9865 0.99598 1.00000\n```\n\n\n:::\n\n```{.r .cell-code}\n# component loadings for each observation\ntidy(pca_fit)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 432 × 3\n   row      PC    value\n   <chr> <dbl>    <dbl>\n 1 1         1 -14.8   \n 2 1         2   1.05  \n 3 1         3  -1.01  \n 4 2         1 -14.8   \n 5 2         2   0.0756\n 6 2         3  -1.23  \n 7 3         1 -14.8   \n 8 3         2   1.05  \n 9 3         3  -1.01  \n10 4         1 -14.7   \n# ℹ 422 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\n# Factor analysis\nfa_fit <- factanal(~ grade + age + scholarship, factors = 1, data = data)\n\n# summary of factor analysis\nfa_fit\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nfactanal(x = ~grade + age + scholarship, factors = 1, data = data)\n\nUniquenesses:\n      grade         age scholarship \n      0.965       0.005       0.888 \n\nLoadings:\n            Factor1\ngrade        0.188 \nage          0.997 \nscholarship -0.334 \n\n               Factor1\nSS loadings      1.142\nProportion Var   0.381\n\nThe degrees of freedom for the model is 0 and the fit was 0.0014 \n```\n\n\n:::\n\n```{.r .cell-code}\ntidy(fa_fit)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n  variable    uniqueness    fl1\n  <chr>            <dbl>  <dbl>\n1 grade            0.965  0.188\n2 age              0.005  0.997\n3 scholarship      0.888 -0.334\n```\n\n\n:::\n:::\n\n\n# Repeated measures ANOVA\n\nRepeated measures ANOVA is used when the same subjects are measured multiple times. The `aov()` function can be used to fit these models, with the formula syntax `y ~ x + Error(subject)`, where `y` is the dependent variable, `x` is the independent variable, and `subject` is the repeated measure. The `Error()` function specifies the repeated measure, and the `data` argument can be used to specify the data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# repeated measures ANOVA\n# redefine data to have two observations per person, the second with random noise added to the grade\nbind_rows(data,\n          data %>% mutate(grade = grade + rnorm(n()))) |>\n  aov(grade ~ reading + Error(id), data = _)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\naov(formula = grade ~ reading + Error(id), data = bind_rows(data, \n    data %>% mutate(grade = grade + rnorm(n()))))\n\nGrand Mean: 2.778323\n\nStratum 1: id\n\nTerms:\n                 reading\nSum of Squares  24.31913\nDeg. of Freedom        1\n\nEstimated effects are balanced\n\nStratum 2: Within\n\nTerms:\n                 reading Residuals\nSum of Squares   22.6930  594.3074\nDeg. of Freedom        1       287\n\nResidual standard error: 1.439013\nEstimated effects are balanced\n```\n\n\n:::\n:::\n\n\n# Go to\n\n-   [Introduction to R](../intro)\n-   [Finding and importing data](../import)\n-   [Data cleaning with `dplyr`](../clean)\n-   [Summary statistics](../summary)\n-   [Data visualization with `ggplot2`](../ggplot)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}