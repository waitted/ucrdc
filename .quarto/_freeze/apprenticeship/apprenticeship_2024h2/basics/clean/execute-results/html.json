{
  "hash": "1c2da58b253fab072410f28b495edf0b",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Data Center Apprenticeship:\\nR basics: Data wrangling with `dplyr`\"\nsubtitle: \"June 2024\" \ndate: \"Last updated: 2025-08-06\"\n---\n\n\n\n\nData wrangling is the process of cleaning, structuring, and enriching raw data into a more usable format. The `dplyr` package is a part of the `tidyverse` and provides a set of functions that can be combined to perform the most common data wrangling tasks. The package is built around the concept of the \"grammar of data manipulation\", which is a consistent set of verbs that can be combined in many ways to achieve the desired result.\n\nIf `tidyverse` is not yet loaded in this R session, please do so now:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n::: {.cell}\n\n:::\n\n\nThe main functions in `dplyr` are `filter()`, `select()`, `mutate()`, `arrange()`, `group_by()`, `summarize()`, and `rename()`. `dplyr` also provides a set of functions for combining datasets: `bind_rows()` and `bind_cols()` for row-wise and column-wise binding, and `left_join()`, `right_join()`, `inner_join()`, and `full_join()` for joining datasets based on common variables. These functions can be combined using the pipe operator `|>` (or `%>%`, they are mostly equivalent) to create a data wrangling workflow. The pipe operator takes the output of the function on its left and passes it as the first argument to the function on its right. This allows you to chain multiple functions together in a single line of code, making your code more readable and easier to understand.\n\nIn the following, we'll work with the `student` datasets imported in the previous section and show how to use the main `dplyr` functions to clean the data so it is suitable for analysis. These steps are useful even if the input data is quite clean, as we often need to work with only a subset of observations/variables, define new variables, or aggregate the data.\n\n# Merging datasets\n\nIn our current application, we have five datasets that contain different observations of the same, larger dataset. So we can list all datasets in a row-binding function to combine them into a single dataset called `student`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstudent <- bind_rows(student1, student2, student3, student4, student5)\n```\n:::\n\n\nIn the following, we'll demonstrate the key data cleaning functions on this merged tibble.\n\n# Filtering observations\n\nIf we want to keep only a subset of observations, we can use the `filter()` function. We can specify a logical condition as the argument to `filter()`, and only observations that meet that condition will be kept. For example, to keep only students who are over 21 years old, we can use the following code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(student, Student_Age > 21)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 27 × 15\n      Id Student_Age Sex    High_School_Type Scholarship Additional_Work\n   <dbl>       <dbl> <chr>  <chr>            <chr>       <chr>          \n 1  5005          22 Male   Private          50%         No             \n 2  5015          26 Male   State            75%         Yes            \n 3  5016          22 Male   State            50%         No             \n 4  5018          22 Male   State            50%         No             \n 5  5023          22 Male   State            50%         Yes            \n 6  5024          25 Male   State            25%         Yes            \n 7  5029          24 Male   State            50%         No             \n 8  5032          25 Male   State            50%         Yes            \n 9  5040          22 Female State            50%         No             \n10  5042          24 Male   State            50%         Yes            \n# ℹ 17 more rows\n# ℹ 9 more variables: Sports_activity <chr>, Transportation <chr>,\n#   Weekly_Study_Hours <dbl>, Attendance <chr>, Reading <chr>, Notes <chr>,\n#   Listening_in_Class <chr>, Project_work <chr>, Grade <chr>\n```\n\n\n:::\n:::\n\n\nIn a pipe workflow, the same code would look like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstudent |> \n  filter(Student_Age > 21)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 27 × 15\n      Id Student_Age Sex    High_School_Type Scholarship Additional_Work\n   <dbl>       <dbl> <chr>  <chr>            <chr>       <chr>          \n 1  5005          22 Male   Private          50%         No             \n 2  5015          26 Male   State            75%         Yes            \n 3  5016          22 Male   State            50%         No             \n 4  5018          22 Male   State            50%         No             \n 5  5023          22 Male   State            50%         Yes            \n 6  5024          25 Male   State            25%         Yes            \n 7  5029          24 Male   State            50%         No             \n 8  5032          25 Male   State            50%         Yes            \n 9  5040          22 Female State            50%         No             \n10  5042          24 Male   State            50%         Yes            \n# ℹ 17 more rows\n# ℹ 9 more variables: Sports_activity <chr>, Transportation <chr>,\n#   Weekly_Study_Hours <dbl>, Attendance <chr>, Reading <chr>, Notes <chr>,\n#   Listening_in_Class <chr>, Project_work <chr>, Grade <chr>\n```\n\n\n:::\n:::\n\n\nWe can also apply logical conditions to character variables, e.g. to keep only students who went to a private high school and who did not receive a failing grade. Filters can be combined with AND (`,` or `&`) and OR (`|`) operators into a single function. Note the use of quotation marks around the character values in the logical condition and the double equal sign `==` to denote equality.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstudent |> \n  filter(High_School_Type == \"Private\", Grade != \"Fail\") \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 23 × 15\n      Id Student_Age Sex    High_School_Type Scholarship Additional_Work\n   <dbl>       <dbl> <chr>  <chr>            <chr>       <chr>          \n 1  5004          18 Female Private          50%         Yes            \n 2  5005          22 Male   Private          50%         No             \n 3  5011          18 Female Private          50%         No             \n 4  5020          18 Male   Private          50%         No             \n 5  5028          18 Male   Private          50%         Yes            \n 6  5035          18 Male   Private          50%         No             \n 7  5036          18 Male   Private          75%         No             \n 8  5041          18 Male   Private          50%         No             \n 9  5050          18 Male   Private          75%         No             \n10  5077          20 Male   Private          25%         No             \n# ℹ 13 more rows\n# ℹ 9 more variables: Sports_activity <chr>, Transportation <chr>,\n#   Weekly_Study_Hours <dbl>, Attendance <chr>, Reading <chr>, Notes <chr>,\n#   Listening_in_Class <chr>, Project_work <chr>, Grade <chr>\n```\n\n\n:::\n:::\n\n\nAnother useful logical operator is `%in%`, which allows you to filter observations based on a list of values. For example, to keep only students who receive either 75% or 100% scholarships, we can use the following code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstudent |> \n  filter(Scholarship %in% c(\"75%\", \"100%\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 65 × 15\n      Id Student_Age Sex    High_School_Type Scholarship Additional_Work\n   <dbl>       <dbl> <chr>  <chr>            <chr>       <chr>          \n 1  5007          18 Male   State            75%         No             \n 2  5012          18 Female Private          75%         Yes            \n 3  5013          18 Female Private          75%         No             \n 4  5014          19 Female State            100%        No             \n 5  5015          26 Male   State            75%         Yes            \n 6  5017          18 Female State            100%        No             \n 7  5019          18 Female State            75%         No             \n 8  5021          18 Male   State            100%        Yes            \n 9  5022          18 Male   State            100%        No             \n10  5030          19 Male   Other            75%         No             \n# ℹ 55 more rows\n# ℹ 9 more variables: Sports_activity <chr>, Transportation <chr>,\n#   Weekly_Study_Hours <dbl>, Attendance <chr>, Reading <chr>, Notes <chr>,\n#   Listening_in_Class <chr>, Project_work <chr>, Grade <chr>\n```\n\n\n:::\n:::\n\n\n# Selecting variables\n\nIf we want to keep only a subset of variables, we can use the `select()` function. We can specify the variables we want to keep (or exclude, with `-` signs) as the arguments to `select()`, and only those variables will be kept. For example, to keep only the `Id` and `Student_Age` variables, we can use the following code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(student, Id, Student_Age)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 145 × 2\n      Id Student_Age\n   <dbl>       <dbl>\n 1  5001          21\n 2  5002          20\n 3  5003          21\n 4  5004          18\n 5  5005          22\n 6  5006          20\n 7  5007          18\n 8  5008          18\n 9  5009          19\n10  5010          21\n# ℹ 135 more rows\n```\n\n\n:::\n:::\n\n\nWe can also select columns based on their location in the dataframe or by looking for patterns in the column names:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(student, 1:3) # select the first three columns\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 145 × 3\n      Id Student_Age Sex   \n   <dbl>       <dbl> <chr> \n 1  5001          21 Male  \n 2  5002          20 Male  \n 3  5003          21 Male  \n 4  5004          18 Female\n 5  5005          22 Male  \n 6  5006          20 Male  \n 7  5007          18 Male  \n 8  5008          18 Female\n 9  5009          19 Female\n10  5010          21 Female\n# ℹ 135 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\nselect(student, starts_with(\"Student\")) # select columns that start with \"Student\"\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 145 × 1\n   Student_Age\n         <dbl>\n 1          21\n 2          20\n 3          21\n 4          18\n 5          22\n 6          20\n 7          18\n 8          18\n 9          19\n10          21\n# ℹ 135 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\nselect(student, -Grade) # keep everything but \"Grade\"\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 145 × 14\n      Id Student_Age Sex    High_School_Type Scholarship Additional_Work\n   <dbl>       <dbl> <chr>  <chr>            <chr>       <chr>          \n 1  5001          21 Male   Other            50%         Yes            \n 2  5002          20 Male   Other            50%         Yes            \n 3  5003          21 Male   State            50%         No             \n 4  5004          18 Female Private          50%         Yes            \n 5  5005          22 Male   Private          50%         No             \n 6  5006          20 Male   State            50%         No             \n 7  5007          18 Male   State            75%         No             \n 8  5008          18 Female State            50%         Yes            \n 9  5009          19 Female Other            50%         No             \n10  5010          21 Female State            50%         No             \n# ℹ 135 more rows\n# ℹ 8 more variables: Sports_activity <chr>, Transportation <chr>,\n#   Weekly_Study_Hours <dbl>, Attendance <chr>, Reading <chr>, Notes <chr>,\n#   Listening_in_Class <chr>, Project_work <chr>\n```\n\n\n:::\n\n```{.r .cell-code}\nselect(student, -c(2, 6, 10)) # keep everything but the 2nd, 6th, and 10th columns\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 145 × 12\n      Id Sex    High_School_Type Scholarship Sports_activity Transportation\n   <dbl> <chr>  <chr>            <chr>       <chr>           <chr>         \n 1  5001 Male   Other            50%         No              Private       \n 2  5002 Male   Other            50%         No              Private       \n 3  5003 Male   State            50%         No              Private       \n 4  5004 Female Private          50%         No              Bus           \n 5  5005 Male   Private          50%         No              Bus           \n 6  5006 Male   State            50%         No              Private       \n 7  5007 Male   State            75%         No              Private       \n 8  5008 Female State            50%         Yes             Bus           \n 9  5009 Female Other            50%         Yes             Bus           \n10  5010 Female State            50%         No              Bus           \n# ℹ 135 more rows\n# ℹ 6 more variables: Weekly_Study_Hours <dbl>, Reading <chr>, Notes <chr>,\n#   Listening_in_Class <chr>, Project_work <chr>, Grade <chr>\n```\n\n\n:::\n:::\n\n\nA pipe workflow allows us to combine the filtering and selecting operations into a single, step-by-step workflow:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstudent |> \n  filter(Student_Age > 21) |> \n  select(Id, Student_Age)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 27 × 2\n      Id Student_Age\n   <dbl>       <dbl>\n 1  5005          22\n 2  5015          26\n 3  5016          22\n 4  5018          22\n 5  5023          22\n 6  5024          25\n 7  5029          24\n 8  5032          25\n 9  5040          22\n10  5042          24\n# ℹ 17 more rows\n```\n\n\n:::\n:::\n\n\n# Creating new variables\n\nIf we want to create a new variable based on existing variables, we can use the `mutate()` function. We can specify the new variable name and the calculation for the new variable as the arguments to `mutate()`, and the new variable will be added to the dataset. For example, we can create a new variable `Daily_Study_Hours` that divides `Weekly_Study_Hours` by 5, a new variable `Class_Participation` that is a logical variable indicating whether the student has at least one \"Yes\" answer for reading, listening, and taking notes, and a new variable `Scholarship_num` that extracts the numeric value of `Scholarship` if the string contains a number.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstudent |> \n  # create new variables\n  mutate(Daily_Study_Hours = Weekly_Study_Hours / 5,\n         Class_Participation = Reading == \"Yes\" | Listening_in_Class == \"Yes\" | Notes == \"Yes\",\n         Scholarship_num =parse_number(Scholarship)) |> \n  # show only ID and the new variables\n  select(Id, Daily_Study_Hours, Class_Participation, Scholarship_num)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 145 × 4\n      Id Daily_Study_Hours Class_Participation Scholarship_num\n   <dbl>             <dbl> <lgl>                         <dbl>\n 1  5001               0   TRUE                             50\n 2  5002               0   TRUE                             50\n 3  5003               0.4 FALSE                            50\n 4  5004               0.4 TRUE                             50\n 5  5005               2.4 TRUE                             50\n 6  5006               0.4 TRUE                             50\n 7  5007               0   TRUE                             75\n 8  5008               0.4 TRUE                             50\n 9  5009               0   FALSE                            50\n10  5010               2.4 TRUE                             50\n# ℹ 135 more rows\n```\n\n\n:::\n:::\n\n\n# Sorting the data\n\nIf we want to sort the data based on one or more variables, we can use the `arrange()` function, taking the tibble and a variable list as its arguments. By default, `arrange()` sorts in ascending order, but you can specify descending order by using the `desc()` function. For example, to sort the data by `Student_Age` in descending order, and `Weekly_Study_Hours` in ascending order, we can use the following code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstudent |> \n  arrange(desc(Student_Age), Weekly_Study_Hours)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 145 × 15\n      Id Student_Age Sex    High_School_Type Scholarship Additional_Work\n   <dbl>       <dbl> <chr>  <chr>            <chr>       <chr>          \n 1  5118          26 Female Private          50%         No             \n 2  5015          26 Male   State            75%         Yes            \n 3  5032          25 Male   State            50%         Yes            \n 4  5056          25 Male   State            50%         Yes            \n 5  5024          25 Male   State            25%         Yes            \n 6  5029          24 Male   State            50%         No             \n 7  5082          24 Male   State            50%         Yes            \n 8  5042          24 Male   State            50%         Yes            \n 9  5085          24 Male   Other            50%         Yes            \n10  5059          23 Male   State            50%         No             \n# ℹ 135 more rows\n# ℹ 9 more variables: Sports_activity <chr>, Transportation <chr>,\n#   Weekly_Study_Hours <dbl>, Attendance <chr>, Reading <chr>, Notes <chr>,\n#   Listening_in_Class <chr>, Project_work <chr>, Grade <chr>\n```\n\n\n:::\n:::\n\n\n# Renaming variables\n\nIf we want to rename variables, we can use the `rename()` function with the argument structure `new name = old name`. For example, we can rename the `Student_Age` variable to `age` and the `Weekly_Study_Hours` variable to `weekly_hours`, we can use the following code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstudent |> \n  rename(age = Student_Age, weekly_hours = Weekly_Study_Hours)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 145 × 15\n      Id   age Sex    High_School_Type Scholarship Additional_Work\n   <dbl> <dbl> <chr>  <chr>            <chr>       <chr>          \n 1  5001    21 Male   Other            50%         Yes            \n 2  5002    20 Male   Other            50%         Yes            \n 3  5003    21 Male   State            50%         No             \n 4  5004    18 Female Private          50%         Yes            \n 5  5005    22 Male   Private          50%         No             \n 6  5006    20 Male   State            50%         No             \n 7  5007    18 Male   State            75%         No             \n 8  5008    18 Female State            50%         Yes            \n 9  5009    19 Female Other            50%         No             \n10  5010    21 Female State            50%         No             \n# ℹ 135 more rows\n# ℹ 9 more variables: Sports_activity <chr>, Transportation <chr>,\n#   weekly_hours <dbl>, Attendance <chr>, Reading <chr>, Notes <chr>,\n#   Listening_in_Class <chr>, Project_work <chr>, Grade <chr>\n```\n\n\n:::\n:::\n\n\n# Categorical variables as factors\n\nIt is often useful to clearly define the levels of a categorical variable, especially if these levels have a meaningful ordering. For unordered categories, R provides the data type `factor`, while for ordered variables the relevant data type is `ordered`. Factor and ordered values appear as character strings when viewed, but are treated as numbers with labels internally, which makes it easier to show descriptives of the variable and include it in models. For example, we can define `High_School_Type` as a factor with three levels and `Attendance` as ordered with the `factor()` and `ordered()` functions. If we don't specify the levels of the factor explicitly, then the levels will be sorted alphabetically.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstudent |> \n  mutate(High_School_Type = factor(High_School_Type),\n         Attendance = ordered(Attendance, levels = c(\"Never\", \"Sometimes\", \"Always\"))) |> \n  select(High_School_Type, Attendance) |> \n  # view variable types and levels by looking at the structure of the data\n  str()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntibble [145 × 2] (S3: tbl_df/tbl/data.frame)\n $ High_School_Type: Factor w/ 3 levels \"Other\",\"Private\",..: 1 1 3 2 2 3 3 3 1 3 ...\n $ Attendance      : Ord.factor w/ 3 levels \"Never\"<\"Sometimes\"<..: 3 3 1 3 3 3 3 2 3 1 ...\n```\n\n\n:::\n:::\n\n\n# Data cleaning as a single pipeline\n\nUntil now we didn't save any of our data wrangling steps as new objects, so the original `student1` object is still unchanged. If we want to save the cleaned data as a new object, we can assign the result of the pipe workflow to a new object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstudent_subset <- student1 |> \n  filter(Student_Age > 21) |> \n  select(Id, Student_Age) |> \n  arrange(desc(Student_Age)) |> \n  rename(age = Student_Age)\n```\n:::\n\n\nTo prepare for the rest of the analysis, let's create a new `data` object that keeps all observations, and converts some of the indicators to numeric and logical, and rename the relevant variables to convenient \"snake case\":\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- student |> \n  mutate(scholarship = parse_number(Scholarship),\n         sex = factor(Sex),\n         # ifelse contains a logical condition, a value if TRUE, and a value if FALSE\n         additional_work = ifelse(Additional_Work == \"Yes\", TRUE, FALSE),\n         reading = ifelse(Reading == \"Yes\", TRUE, FALSE),\n         notes = ifelse(Notes == \"Yes\", TRUE, FALSE),\n         listening = ifelse(Listening_in_Class == \"Yes\", TRUE, FALSE),\n         # case_when is an expansion of ifelse: it allows multiple conditions\n         # the value after the tilde (~) is the value if the condition is TRUE\n         grade = case_when(\n           Grade == \"Fail\" ~ 0,\n           Grade == \"DD\" ~ 1,\n           Grade == \"DC\" ~ 1.5,\n           Grade == \"CC\" ~ 2,\n           Grade == \"CB\" ~ 3,\n           Grade == \"BB\" ~ 3,\n           Grade == \"BA\" ~ 4,\n           Grade == \"AA\" ~ 4\n         )) |> \n  rename(id = Id, age = Student_Age) |> \n  select(id, age, sex, scholarship, additional_work, reading, notes, listening, grade)\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n# Go to\n\n-   [Introduction to R](../intro)\n-   [Finding and importing data](../import)\n-   [Summary statistics](../summary)\n-   [Data visualization with `ggplot2`](../ggplot)\n-   [Hypothesis testing / modelling](../tests)\n",
    "supporting": [
      "clean_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}