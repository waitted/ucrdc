{
  "hash": "d366b857752f1c0f5a1b6ee6fd4f9439",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Data Center Apprenticeship:\\nAdvanced treatment of data types and functions in R\"\nsubtitle: \"Spring 2024\" \ndate: \"Last updated: 2025-08-06\"\n---\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(lubridate) # for dates\n```\n:::\n\n\n# More on data types\n\nSource: Hadley Wickham: [Advanced R](https://adv-r.hadley.nz/vectors-chap.html) (Chapter 3: Vectors).\n\n## Vectors\n\n### Scalars: testing and coercion\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a tibble with logical column, coerce it to other types\nvectors <- tibble(\n logical = c(TRUE, FALSE, NA),\n integer = as.integer(logical),\n numeric = as.numeric(logical),\n character_log = as.character(logical),\n character_num = as.character(numeric)\n)\n\nprint(vectors)\n\n# Logical is coerced to numeric\nclass(c(vectors$logical, vectors$numeric))\n\n# Logical and numeric are coerced to character\nclass(c(vectors$logical, vectors$numeric, vectors$character_log, vectors$character_num))\n\n# Logical is not numeric or character, just coercible to them\nis.numeric(vectors$logical)\nis.character(vectors$logical)\n```\n:::\n\n\n### Factors: coercion, levels, ordering\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Logical and factor is numbered differently when coerced to numeric\nfactors <- tibble(\n logical = c(TRUE, FALSE, NA),\n factor = as.factor(logical),\n numeric_log = as.numeric(logical),\n numeric_fac = as.numeric(factor)\n)\n\nprint(factors)\n\n# Define a character vector\nchar <- c(\"x\", \"x\", \"x\")\n\n# Convert character vector to factor with levels x and y\nfactor <- factor(char, levels = c(\"x\", \"y\"))\n\n# Only factor can be coerced to numeric, not character\nas.numeric(char)\nas.numeric(factor)\n\n# Table counts all factor levels, even with no observations\ntable(char)\ntable(factor)\n\n# Order character vector with levels x < y\nordered(char, levels = c(\"x\", \"y\"))\n```\n:::\n\n\n### Dates: `lubridate`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a vector of dates\ndates <- c(ymd(20201001), dmy(\"31082022\"), Sys.Date(), today())\ndates\n\n# Convert dates to datetime\nas_datetime(dates)\n\n# Convert dates to numeric\nas.numeric(dates)\n\n# Reconstruct dates from numeric representation as number of days since base date (01/01/1970)\nymd(19700101) + days(as.numeric(dates))\n\n# Get current date and time\nnow()\n\n# Convert decimal years to date\ndate_decimal(c(1990, 1990.1, 1990.5))\n\n# Extract year, quarter, and week from dates\nyear(dates)\nquarter(dates)\nweek(dates)\n\n# Difference between time and difftime\ndates + months(1)\ndates + dmonths(1)\n\n# Round down dates to nearest day \nfloor_date(dates + dmonths(1), unit = \"day\")\n```\n:::\n\n\n### Vector attributes\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a named vector\nv <- c(\"a\" = 1, \"b\" = 2, \"c\" = 3)\n\n# Add an attribute 'other_attribute' to 'v'\nattr(v, \"other_attribute\") <- \"x\"\n\n# Display attributes of 'v'\nattributes(v)\n\n# Change names of 'v'\nnames(v) <- c(\"a1\", \"b1\", \"c1\")\nv <- setNames(v, c(\"a2\", \"b2\", \"c2\"))\n\n# Convert 'v' to a dataframe and add row names as a column\n# Note: as_tibble() loses rownames\nas.data.frame(v) |> rownames_to_column()\n\n# Get dimensions of 'v'\n# vectors always have NULL dimension\ndim(v)\n\n# Get dimensions of 'v' as a matrix \n# matrices have two dimensions (rows x columns)\ndim(as.matrix(v))\n```\n:::\n\n\n### NA, NULL, NaN\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# NA: missing\n# NaN: not a number\n# NULL: special object of length 0\nna <- c(NA, NA_integer_, NA_real_, NaN, NULL)\n\n# NULL does not contribute to vector length/content\nlength(na)\n# NA, NaN are all NA, but only NaN is NaN\nis.na(na)\nis.nan(na)\n# object is NULL if it only contains NULL\nis.null(na)\n\n# NA and NaN create an observation\ntibble(x = NA)\ntibble(x = NaN)\n# NULL creates tibble with 0 rows, 0 columns\ntibble(x = NULL)\n```\n:::\n\n\n## Lists\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define list with elements of different types, lengths\nl <- list(\n  1:3, \n  \"a\", \n  c(TRUE, FALSE), \n  x = tibble(y = c(2.3, 5.9), z = c(5, 6)),\n  l1 = list(l2 = list(1, 2, 3), l3 = list(4, 5))\n)\n\n# Access elements of 'l' using different methods\nl[1]\nl[[1]]\nl$x\nl$x$y\nl[\"l1\"]\nl[[\"l1\"]]\nl$l1\nl$l1$l2\nl$l1[[\"l2\"]]\nl$l1[[1]]\n\n# convert list to a single vector (character, due to coercion)\nunlist(l)\n```\n:::\n\n\n## Data frames and tibbles\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a data frame and a tibble with the same contents\ndf <- data.frame(x = 1:3, y = letters[1:3])\ntbl <- tibble(x = 1:3, y = letters[1:3])\n\n# Compare attributes of 'df' and 'tbl'\nattributes(df)\nattributes(tbl)\n\n# Get number of rows and columns of 'df'\nnrow(df)\nncol(df)\n\n# Get dimensions of 'df'\ndim(df)\n\n# Get names of 'df'\nnames(df)\n\n# Create a complex tibble \nd <- tibble(\"1 problematic variable name\" = 1:3, \n            y = letters[1:3], \n            z = list(c(1:3), c(4:6), c(7:9)),\n            tib = list(tibble(x1 = 1:2, y1 = letters[1:2]),\n                       tibble(x1 = 3:4, y1 = letters[3:4]),\n                       tibble(x1 = 5:6, y1 = letters[5:6])))\n\n# Select a variable; result: tibble\nselect(d, y)\nd[ , \"y\"]\nd[ , 2]\n\n# Pull a variable; result: vector\npull(d, y)\nd$y\nd[[\"y\"]]\nd[[2]]\n\n# Use backquotes for problematic names\nselect(d, `1 problematic variable name`)\nd[ , \"1 problematic variable name\"]\nd[ , 1]\n\npull(d, `1 problematic variable name`)\nd$`1 problematic variable name`\nd[[\"1 problematic variable name\"]]\nd[[1]]\n\n# Select all variables containing a single lowercase letter\nselect(d, matches(\"^[a-z]$\"))\n# Select which rows and columns to keep\nd[2:3, c(1, 3)]\n\n# Unnest 'z' and 'tib' from 'd'\nd |> unnest(z)\nd |> unnest(tib)\n# Default unnest behavior: unnest all list columns (but length mismatch error)\n# d |> unnest()\n```\n:::\n\n\n# Writing your own functions\n\nSource: Hadley Wickham and Garrett Grolemund: [R for Data Science](https://r4ds.had.co.nz/functions.html) (Chapter 19: Functions); Hadley Wickham, Mine Ã‡etinkaya-Rundel, and Garrett Grolemund: [R for Data Science (2e)](https://r4ds.hadley.nz/functions) (Chapter 25: Functions)\n\n## What does a function look like?\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Access function definition\nsd\n\n# Defining a simple function: rescale a vector so that all elements are between 0 and 1\nrescale01 <- function(x) {\n  (x - min(x)) / (max(x) - min(x))\n}\n\n# Use function defined in global environment\nrescale01(x = c(1, 4, 5, 8, 10))\n\n# For short functions, use one line and omit the braces\nrescale01 <- function(x) (x - min(x)) / (max(x) - min(x))\n```\n:::\n\n\n## Function name, arguments, body, return value(s)\n\nFunction naming:\n\n-   informative, with verbs\n-   if using multiple related functions, use common prefix (see e.g. `str_...` family)\n-   don't override built-in functions\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Arguments with default values\nrescale01 <- function(x = 1:10) {\n  (x - min(x)) / (max(x) - min(x))\n}\n\nrescale01()\nrescale01(1:10)\nrescale01(x = 1:10)\n\n# ... argument\ncommas <- function(...) paste(..., collapse = \", \")\ncommas(letters[1:10])\n\n# Unexpected results in logical statements\nnames <- tibble(id = 1:3, name = LETTERS[1:3])\n\nfilter_name <- function(data, name) filter(data, name == name)\nfilter_name(names, name = \"B\")\n\nfilter_name <- function(data, n) filter(data, name == n)\nfilter_name(names, n = \"B\")\n\n# Return values with and without return statement\nrescale01 <- function(x) {\n  (x - min(x)) / (max(x) - min(x))\n}\n\nrescale01 <- function(x) {\n  result <- (x - min(x)) / (max(x) - min(x))\n  result\n}\n\nrescale01 <- function(x) {\n  result <- (x - min(x)) / (max(x) - min(x))\n  return(result)\n}\n\n# access result only if assigned to an object\nrescale01 <- function(x) {\n  result <- (x - min(x)) / (max(x) - min(x))\n}\n\n# List returns\nrescale01 <- function(x) {\n  min <- min(x)\n  max <- max(x)\n  result <- (x - min) / (max - min)\n  \n  # returned list\n  list(x = result, original_minimum = min, original_maximum = max)\n}\n\n# Access elements of list return\nrescale01(1:10)$original_minimum\n# better method for computation efficiency\nres <- rescale01(1:10)\nres$x\n\n# Invisible returns: return object without displaying it\nshow_missings <- function(df) {\n  n <- sum(is.na(df))\n  cat(\"Missing values: \", n, \"\\n\", sep = \"\")\n  \n  invisible(df)\n}\n\ntibble(x = rep(c(1, 2, NA), times = 4),\n       y = letters[1:12]) |> \n  show_missings() |> \n  drop_na() |> \n  show_missings()\n```\n:::\n\n\n## Tidy functions: pipes, tidy evaluation\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Mutate functions\n# input: one vector; output: one vector (same length)\nz_score <- function(x) {\n  (x - mean(x, na.rm = TRUE)) / sd(x, na.rm = TRUE)\n}\n\nfirst_upper <- function(x) {\n  str_sub(x, 1, 1) <- str_to_upper(str_sub(x, 1, 1))\n  x\n}\n\ntibble(x = 1:10,\n       y = paste0(\"test\", x)) |> \n  mutate(z_score = z_score(x),\n         y_upper = first_upper(y))\n\n## Summarize functions\n# input: one vector; output: one value\nn_missing <- function(x) {\n  sum(is.na(x))\n} \n\ncommas <- function(x) {\n  str_flatten(x, collapse = \", \", last = \" and \")\n}\n\ntibble(x = rep(c(1, 2, NA), times = 4),\n       y = letters[1:12]) |> \n  summarize(x_missing = n_missing(x),\n            y = commas(y))\n\ntibble(x = rep(c(1, 2, NA), times = 4),\n       y = letters[1:12],\n       group = rep(1:2, each = 6)) |> \n  group_by(group) |> \n  summarize(x_missing = n_missing(x),\n            y = commas(y))\n```\n:::\n\n\nDataframe functions can be embedded into pipe workflows of data wrangling: input and output are both dataframes, so you can take additional steps of data manipulation before and after calling the function.\n\nThe issue you're likely to encounter when writing dataframe functions is having to override the default tidy evaluation. Tidy evaluation is why you can refer to variable names as objects in `dplyr` functions (e.g. `filter(type == 1)`). Because of tidy evaluation, if you specify a variable name as a function argument, referring to the argument as an object inside the function body (as you would with vector functions), R will take the argument name instead the argument value you define in the function call to be the variable used in the function body. Embracing the variable names in question tells R that you're referring to the function argument, not the variable name directly.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Dataframe functions\n# input: dataframe; output: dataframe\n\n# group_var and mean_var treated as variable names, not function arguments\ngrouped_mean <- function(df, group_var, mean_var) {\n  df |> \n    group_by(group_var) |> \n    summarize(mean(mean_var))\n}\n\n# error: variables not found\ntibble(x = 1:20,\n       group = rep(1:2, each = 10)) |> \n  grouped_mean(group_var = group, mean_var = x)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# embracing arguments means they take on the value defined in the function call\ngrouped_mean <- function(df, group_var, mean_var) {\n  df |> \n    group_by({{ group_var }}) |> \n    summarize(mean({{ mean_var }}))\n}\n\n# works as expected\ntibble(x = 1:20,\n       group = rep(1:2, each = 10)) |> \n  grouped_mean(group_var = group, mean_var = x)\n\n# More examples\ncount_prop <- function(df, var, sort = FALSE) {\n  df |>\n    count({{ var }}, sort = sort) |>\n    mutate(prop = n / sum(n))\n}\n\ndiamonds |> count_prop(clarity)\n\nunique_where <- function(df, condition, var) {\n  df |> \n    filter({{ condition }}) |> \n    distinct({{ var }}) |> \n    arrange({{ var }})\n}\n\ndiamonds |> unique_where(cut == \"Ideal\", color)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n## Plot functions\n\n# Define the repetitive part of ggplot code\nhistogram <- function(df, var) {\n  df |> \n    ggplot(aes(x = {{ var }})) + \n    geom_histogram() \n}\n\nhistogram(diamonds, carat)\n\n# Add more plot elements, data wrangling\ndiamonds |> \n  filter(color == \"G\") |> \n  histogram(carat) +\n  facet_wrap(~cut)\n\n# Add labels with rlang::englue\n# variables in {{ }}, other arguments in { }\nhistogram <- function(df, var, binwidth) {\n  label <- rlang::englue(\"A histogram of {{var}} with binwidth {binwidth}\")\n  \n  df |> \n    ggplot(aes(x = {{ var }})) + \n    geom_histogram(binwidth = binwidth) + \n    labs(title = label)\n}\n\ndiamonds |> histogram(carat, 0.1)\n```\n:::\n\n\n## Conditional execution\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Use for early return/stopping/error messages\n\n# Return normal mean if weights are not specified\nweighted_mean <- function(x, w = NULL) {\n  if (is.null(w)) {\n    return(mean(x))\n  }\n  sum(w * x) / sum(w)\n}\n\n# Stop with custom error message\nweighted_mean <- function(x, w) {\n  if (length(x) != length(w)) {\n    stop(\"`x` and `w` must be the same length\")\n  }\n  sum(w * x) / sum(w)\n}\n\n# Alternatively, use stopifnot for a generic error\nweighted_mean <- function(x, w) {\n  stopifnot(length(x) == length(w))\n  sum(w * x) / sum(w)\n}\n\n## Use conditions for different behavior with different arguments\nweighted_mean <- function(x, w, na.rm = FALSE) {\n  stopifnot(length(x) == length(w), is.logical(na.rm), length(na.rm) == 1)\n  \n  # Drop NA values from x and w if na.rm == TRUE\n  if (na.rm) {\n    na <- is.na(x) | is.na(w)\n    x <- x[!na]\n    w <- w[!na]\n  }\n  \n  sum(w * x) / sum(w)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n## Nested if else\nif (this) {\n  # do that\n} else if (that) {\n  # do something else\n} else {\n  # do a different thing\n}\n```\n:::\n\n\n## What objects exist in which environment?\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Functions can find objects defined outside the function\n\n# works if y is defined outside the function (but not advised)\nf <- function(x) {\n  x + y\n} \n\ny <- 5\nf(2)\n\n## Functions defined inside the function don't exist outside the function\nf <- function(x) {\n  res <- x + y\n  res\n}\n\ny <- 5\nf(2)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nres\n```\n:::\n\n\n# Iteration with functionals\n\nHadley Wickham: [Advanced R](https://adv-r.hadley.nz/functionals.html#map) (Chapter 9: Functionals).\n\n## Why should you use functionals?\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Most R functions are vectorized\n\n# Other languages:\nresults <- NULL\nfor (i in 1:3) {\n  results[i] <- paste(\"result\", i)\n}\n\n# R: vectorized function\nresults <- paste(\"result\", 1:3)\n\n# Vectorized functions don't always give expected results\nx <- rnorm(10)\nmean(x, trim = c(0, 0.1, 0.2, 0.5))\n\n# To get a list of means with different trim values, iterate explicitly\n\n# One approach: for-loop\nmeans <- NULL; i <- 1\nfor (t in c(0, 0.1, 0.2, 0.5)) {\n  means[i] <- mean(x, trim = t)\n  i <- i + 1\n}\n\n# Other approach: map()\nmeans <- map(c(0, 0.1, 0.2, 0.5), ~mean(x, trim = .x))\n```\n:::\n\n\n## `map()` and its versions\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# map() iterates over one vector, gives list\nmap(c(0, 0.1, 0.2, 0.5), ~mean(x, trim = .x))\n\n# map_dbl/chr/df/etc. gives specified output type (if possible)\nmap_dbl(c(0, 0.1, 0.2, 0.5), ~mean(x, trim = .x))\nmap_chr(c(0, 0.1, 0.2, 0.5), ~mean(x, trim = .x))\nmap_df(c(0, 0.1, 0.2, 0.5), ~tibble(trim = .x,\n                                    trimmed_mean = mean(x, trim = .x)))\n\n# map2() family iterates over 2 vectors\nn <- c(10, 50, 100, 500)\ntrims <- c(0, 0.1, 0.2, 0.5)\nmap2_df(n, trims, ~tibble(n = .x,\n                          trim = .y,\n                          trimmed_mean = mean(rnorm(.x), trim = .y)))\n\n# pmap() family iterates over n vectors (parallel)\nn <- c(10, 50, 100, 500)\nmeans <- c(0, 1, 2, 5)\ntrims <- c(0, 0.1, 0.2, 0.5)\npmap_df(list(n, means, trims), \n        ~tibble(n = ..1,\n                mean = ..2,\n                trim = ..3,\n                trimmed_mean = mean(rnorm(..1, mean = ..2), trim = ..3)))\n\n# Or use reference names with a named list\npmap_df(list(n = n, means = means, trims = trims), \n        function (n, means, trims) tibble(\n          n = n,\n          mean = means,\n          trim = trims,\n          trimmed_mean = mean(rnorm(n, mean = means), trim = trims)))\n\n# Iterate over a tibble rather than a list\nparams <- tribble(\n  ~ n, ~ min, ~ max,\n   1,     0,     1,\n   2,    10,   100,\n   3,   100,  1000\n)\npmap(params, runif)\n```\n:::\n\n\n## Functionals in tidy data wrangling\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Compare methods:\n\n# Draws one random number with mean 0, recycles\ntibble(true_mean = 0:5) |> \n  mutate(sample = rnorm(1, mean = true_mean))\n\n# Draws one random number per mean\ntibble(true_mean = 0:5) |> \n  mutate(sample = map_dbl(true_mean, ~rnorm(1, mean = .x)))\n\n# Draws 5 random numbers per mean, creates list column\ntibble(true_mean = 0:5) |> \n  mutate(sample = map(true_mean, ~rnorm(5, mean = .x))) |> \n  unnest()\n\n# Without map(): error\ntibble(true_mean = 0:5) |> \n  mutate(sample = rnorm(5, mean = true_mean))\n```\n:::\n\n\n## Applying methods to multiple variables with `across()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- tibble(\n  a = rnorm(10),\n  b = rnorm(10),\n  c = rnorm(10),\n  d = rnorm(10)\n)\n\ndf |> summarize(\n  n = n(),\n  a = median(a),\n  b = median(b),\n  c = median(c),\n  d = median(d)\n)\n\n# Get column medians for columns a to d\ndf |> summarize(\n  n = n(),\n  across(a:d, median)\n)\n\n# Get column medians for all columns\ndf |> summarize(\n  n = n(),\n  across(everything(), median)\n)\n\n# Other variable list specifications:\n\n# starts_with(\"s\") # equivalent to regex \"^s.*\"\n# ends_with(\"s\") # equivalent to regex \".*s$\"\n# contains(\"s\") # equivalent to regex \"s\"\n# matches(\"s\") # equivalent to contains() but \"s\" can be regex\n# where(is.numeric) # all numeric (or other type) variables\n# ! negates selectors (e.g. !where(is.numeric))\n\n# Explicit function arguments\ndf |> summarize(\n  n = n(),\n  across(everything(), ~mean(., na.rm = TRUE))\n)\n\n# More complex functions, overwrite existing variable\ndf |> \n  mutate(across(everything(), ~ (. - min(.)) / (max(.) - min(.))))\n\n# More complex functions, create new variable\ndf |> \n  mutate(across(everything(), list(rescaled = ~ (. - min(.)) / (max(.) - min(.)))))\n\n# Multiple functions\ndf |> summarize(\n  n = n(),\n  across(everything(), \n         list(mean = ~mean(., na.rm = TRUE), \n              median = median),\n         .names = \"{.fn}_{.col}\")\n)\n```\n:::\n\n\n## Filtering with `if_any` and `if_all`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> filter(if_any(a:d, ~ . > 0))\ndf |> filter(if_all(a:b, ~ . > 0))\n\n# across() is equivalent to if_all but less intuitive\ndf |> filter(across(a:b, ~ . > 0))\n```\n:::\n",
    "supporting": [
      "data-types_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}